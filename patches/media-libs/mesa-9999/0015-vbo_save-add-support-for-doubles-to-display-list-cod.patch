From 8d9637f86fec49243703c677623d10def312705d Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 28 Jun 2018 12:40:20 +1000
Subject: [PATCH 15/18] vbo_save: add support for doubles to display list code

Required for ARB_vertex_attrib_64bit compat profile support.
---
 src/mesa/main/mtypes.h       |  2 +-
 src/mesa/vbo/vbo_private.h   |  3 +++
 src/mesa/vbo/vbo_save_api.c  | 18 ++++++++++++------
 src/mesa/vbo/vbo_save_draw.c | 18 +++++++++++++-----
 4 files changed, 29 insertions(+), 12 deletions(-)

diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 0dfff31396..7ef7a3f110 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -4432,7 +4432,7 @@ struct gl_dlist_state
    GLvertexformat ListVtxfmt;
 
    GLubyte ActiveAttribSize[VERT_ATTRIB_MAX];
-   GLfloat CurrentAttrib[VERT_ATTRIB_MAX][4];
+   GLfloat CurrentAttrib[VERT_ATTRIB_MAX][8];
 
    GLubyte ActiveMaterialSize[MAT_ATTRIB_MAX];
    GLfloat CurrentMaterial[MAT_ATTRIB_MAX][4];
diff --git a/src/mesa/vbo/vbo_private.h b/src/mesa/vbo/vbo_private.h
index 3f7d0dc608..86f6b41b79 100644
--- a/src/mesa/vbo/vbo_private.h
+++ b/src/mesa/vbo/vbo_private.h
@@ -214,6 +214,9 @@ _vbo_set_attrib_format(struct gl_context *ctx,
 {
    const GLboolean integer = vbo_attrtype_to_integer_flag(type);
    const GLboolean doubles = vbo_attrtype_to_double_flag(type);
+
+   if (doubles)
+      size /= 2;
    _mesa_update_array_format(ctx, vao, attr, size, type, GL_RGBA,
                              GL_FALSE, integer, doubles, offset);
    /* Ptr for userspace arrays.
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index 945a0c8bff..d5b43d0684 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -791,9 +791,12 @@ copy_to_current(struct gl_context *ctx)
       const int i = u_bit_scan64(&enabled);
       assert(save->attrsz[i]);
 
-      save->currentsz[i][0] = save->attrsz[i];
-      COPY_CLEAN_4V_TYPE_AS_UNION(save->current[i], save->attrsz[i],
-                                  save->attrptr[i], save->attrtype[i]);
+      if (save->attrtype[i] == GL_DOUBLE ||
+          save->attrtype[i] == GL_UNSIGNED_INT64_ARB)
+         memcpy(save->current[i], save->attrptr[i], save->attrsz[i] * sizeof(GLfloat));
+      else
+         COPY_CLEAN_4V_TYPE_AS_UNION(save->current[i], save->attrsz[i],
+                                     save->attrptr[i], save->attrtype[i]);
    }
 }
 
@@ -935,11 +938,13 @@ upgrade_vertex(struct gl_context *ctx, GLuint attr, GLuint newsz)
  * get a glTexCoord4f() or glTexCoord1f() call.
  */
 static void
-fixup_vertex(struct gl_context *ctx, GLuint attr, GLuint sz)
+fixup_vertex(struct gl_context *ctx, GLuint attr,
+             GLuint sz, GLenum newType)
 {
    struct vbo_save_context *save = &vbo_context(ctx)->save;
 
-   if (sz > save->attrsz[attr]) {
+   if (sz > save->attrsz[attr] ||
+       newType != save->attrtype[attr]) {
       /* New size is larger.  Need to flush existing vertices and get
        * an enlarged vertex format.
        */
@@ -994,9 +999,10 @@ reset_vertex(struct gl_context *ctx)
 #define ATTR_UNION(A, N, T, C, V0, V1, V2, V3)			\
 do {								\
    struct vbo_save_context *save = &vbo_context(ctx)->save;	\
+   int sz = (sizeof(C) / sizeof(GLfloat));			\
 								\
    if (save->active_sz[A] != N)					\
-      fixup_vertex(ctx, A, N);					\
+      fixup_vertex(ctx, A, N * sz, T);				\
 								\
    {								\
       C *dest = (C *)save->attrptr[A];                          \
diff --git a/src/mesa/vbo/vbo_save_draw.c b/src/mesa/vbo/vbo_save_draw.c
index 71620e9a3c..409a353b52 100644
--- a/src/mesa/vbo/vbo_save_draw.c
+++ b/src/mesa/vbo/vbo_save_draw.c
@@ -54,16 +54,24 @@ copy_vao(struct gl_context *ctx, const struct gl_vertex_array_object *vao,
       struct gl_array_attributes *currval = &vbo->current[shift + i];
       const GLubyte size = attrib->Size;
       const GLenum16 type = attrib->Type;
-      fi_type tmp[4];
+      fi_type tmp[8];
+      int dmul = 1;
 
-      COPY_CLEAN_4V_TYPE_AS_UNION(tmp, size, *data, type);
+      if (type == GL_DOUBLE ||
+          type == GL_UNSIGNED_INT64_ARB)
+         dmul = 2;
+
+      if (dmul == 2)
+         memcpy(tmp, *data, size * dmul * sizeof(GLfloat));
+      else
+         COPY_CLEAN_4V_TYPE_AS_UNION(tmp, size, *data, type);
 
       if (type != currval->Type ||
-          memcmp(currval->Ptr, tmp, 4 * sizeof(GLfloat)) != 0) {
-         memcpy((fi_type*)currval->Ptr, tmp, 4 * sizeof(GLfloat));
+          memcmp(currval->Ptr, tmp, 4 * sizeof(GLfloat) * dmul) != 0) {
+         memcpy((fi_type*)currval->Ptr, tmp, 4 * sizeof(GLfloat) * dmul);
 
          currval->Size = size;
-         currval->_ElementSize = size * sizeof(GLfloat);
+         currval->_ElementSize = size * sizeof(GLfloat) * dmul;
          currval->Type = type;
          currval->Integer = vbo_attrtype_to_integer_flag(type);
          currval->Doubles = vbo_attrtype_to_double_flag(type);
-- 
2.18.0

