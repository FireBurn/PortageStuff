From 92c3514abbdd46a99015c4f1f9012726abab3acd Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 21 Jun 2018 20:42:28 +1000
Subject: [PATCH 10/18] mesa: add missing display list support for
 ARB_compute_shader

The extension is enabled for compat profile but there is currently
no display list support.
---
 src/mesa/main/dlist.c | 87 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 87 insertions(+)

diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index b2b1f723a1..c11b4c06fe 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -510,6 +510,10 @@ typedef enum
    OPCODE_SAMPLER_PARAMETERIIV,
    OPCODE_SAMPLER_PARAMETERUIV,
 
+   /* ARB_compute_shader */
+   OPCODE_DISPATCH_COMPUTE,
+   OPCODE_DISPATCH_COMPUTE_INDIRECT,
+
    /* GL_ARB_sync */
    OPCODE_WAIT_SYNC,
 
@@ -604,6 +608,7 @@ typedef union gl_dlist_node Node;
 union pointer
 {
    void *ptr;
+   GLintptr intptr;
    GLuint dwords[POINTER_DWORDS];
 };
 
@@ -643,6 +648,41 @@ get_pointer(const Node *node)
 }
 
 
+/**
+ * Save a 4 or 8-byte pointer at dest (and dest+1).
+ */
+static inline void
+save_intpointer(Node *dest, GLintptr src)
+{
+   union pointer p;
+   unsigned i;
+
+   STATIC_ASSERT(POINTER_DWORDS == 1 || POINTER_DWORDS == 2);
+   STATIC_ASSERT(sizeof(Node) == 4);
+
+   p.intptr = src;
+
+   for (i = 0; i < POINTER_DWORDS; i++)
+      dest[i].ui = p.dwords[i];
+}
+
+
+/**
+ * Retrieve a 4 or 8-byte pointer from node (node+1).
+ */
+static inline GLintptr
+get_intpointer(const Node *node)
+{
+   union pointer p;
+   unsigned i;
+
+   for (i = 0; i < POINTER_DWORDS; i++)
+      p.dwords[i] = node[i].ui;
+
+   return p.intptr;
+}
+
+
 /**
  * Used to store a 64-bit uint in a pair of "Nodes" for the sake of 32-bit
  * environment.
@@ -6570,6 +6610,41 @@ save_DrawTransformFeedbackStreamInstanced(GLenum mode, GLuint name,
    }
 }
 
+static void GLAPIENTRY
+save_DispatchCompute(GLuint num_groups_x, GLuint num_groups_y,
+                     GLuint num_groups_z)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   Node *n;
+   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
+   n = alloc_instruction(ctx, OPCODE_DISPATCH_COMPUTE, 3);
+   if (n) {
+      n[1].ui = num_groups_x;
+      n[2].ui = num_groups_y;
+      n[3].ui = num_groups_z;
+   }
+   if (ctx->ExecuteFlag) {
+      CALL_DispatchCompute(ctx->Exec, (num_groups_x, num_groups_y,
+                                       num_groups_z));
+   }
+}
+
+static void GLAPIENTRY
+save_DispatchComputeIndirect(GLintptr indirect)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   Node *n;
+   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
+   n = alloc_instruction(ctx, OPCODE_DISPATCH_COMPUTE_INDIRECT,
+                         POINTER_DWORDS);
+   if (n) {
+      save_intpointer(&n[1], indirect);
+   }
+   if (ctx->ExecuteFlag) {
+      CALL_DispatchComputeIndirect(ctx->Exec, (indirect));
+   }
+}
+
 static void GLAPIENTRY
 save_UseProgram(GLuint program)
 {
@@ -10429,6 +10504,14 @@ execute_list(struct gl_context *ctx, GLuint list)
             }
             break;
 
+         /* ARB_compute_shader */
+         case OPCODE_DISPATCH_COMPUTE:
+            CALL_DispatchCompute(ctx->Exec, (n[1].ui, n[2].ui, n[3].ui));
+            break;
+         case OPCODE_DISPATCH_COMPUTE_INDIRECT:
+            CALL_DispatchComputeIndirect(ctx->Exec, (get_intpointer(&n[1])));
+            break;
+
          /* GL_ARB_sync */
          case OPCODE_WAIT_SYNC:
             {
@@ -11138,6 +11221,10 @@ _mesa_initialize_save_table(const struct gl_context *ctx)
    SET_DepthRangeArrayv(table, save_DepthRangeArrayv);
    SET_DepthRangeIndexed(table, save_DepthRangeIndexed);
 
+   /* 122. ARB_compute_shader */
+   SET_DispatchCompute(table, save_DispatchCompute);
+   SET_DispatchComputeIndirect(table, save_DispatchComputeIndirect);
+
    /* 173. GL_EXT_blend_func_separate */
    SET_BlendFuncSeparate(table, save_BlendFuncSeparateEXT);
 
-- 
2.18.0

