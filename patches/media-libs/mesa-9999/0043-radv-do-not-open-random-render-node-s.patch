From 3c849621bbdee4bc5bc1933247b0c35b4e3ff524 Mon Sep 17 00:00:00 2001
From: Emil Velikov <emil.velikov@collabora.com>
Date: Fri, 10 Mar 2017 12:27:58 +0000
Subject: [PATCH 43/44] radv: do not open random render node(s)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

drmGetDevices2() provides us with enough flexibility to build heuristics
upon. Opening a random node on the other hand will wake up the device,
regardless if it's the one we're interested or not.

v2: Rebase.
v3: Return VK_ERROR_INCOMPATIBLE_DRIVER for no devices (Ilia)

Cc: Michel DÃ¤nzer <michel.daenzer@amd.com>
Cc: Dave Airlie <airlied@redhat.com>
Signed-off-by: Emil Velikov <emil.velikov@collabora.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl> (v1)
Reviewed-by: Eric Engestrom <eric.engestrom@imgtec.com> (v1)
---
 src/amd/vulkan/radv_device.c | 48 +++++++++++++++++++++++++++++++++-----------
 1 file changed, 36 insertions(+), 12 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 17529c1f88..d8a903f077 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -379,28 +379,52 @@ void radv_DestroyInstance(
 	vk_free(&instance->alloc, instance);
 }
 
-VkResult radv_EnumeratePhysicalDevices(
-	VkInstance                                  _instance,
-	uint32_t*                                   pPhysicalDeviceCount,
-	VkPhysicalDevice*                           pPhysicalDevices)
+static VkResult
+radv_enumerate_devices(struct radv_instance *instance)
 {
-	RADV_FROM_HANDLE(radv_instance, instance, _instance);
-	VkResult result;
+	/* TODO: Check for more devices ? */
+	drmDevicePtr devices[8];
+	VkResult result = VK_ERROR_INCOMPATIBLE_DRIVER;
+	int max_devices;
+
+	instance->physicalDeviceCount = 0;
+
+	max_devices = drmGetDevices2(0, devices, sizeof(devices));
+	if (max_devices < 1)
+		return VK_ERROR_INCOMPATIBLE_DRIVER;
+
+	for (unsigned i = 0; i < (unsigned)max_devices; i++) {
+		if (devices[i]->available_nodes & 1 << DRM_NODE_RENDER &&
+		    devices[i]->bustype == DRM_BUS_PCI &&
+		    devices[i]->deviceinfo.pci->vendor_id == 0x1002) {
 
-	if (instance->physicalDeviceCount < 0) {
-		char path[20];
-		instance->physicalDeviceCount = 0;
-		for (unsigned i = 0; i < RADV_MAX_DRM_DEVICES; i++) {
-			snprintf(path, sizeof(path), "/dev/dri/renderD%d", 128 + i);
 			result = radv_physical_device_init(instance->physicalDevices +
 			                                   instance->physicalDeviceCount,
-			                                   instance, path);
+			                                   instance,
+			                                   devices[i]->nodes[DRM_NODE_RENDER]);
 			if (result == VK_SUCCESS)
 				++instance->physicalDeviceCount;
 			else if (result != VK_ERROR_INCOMPATIBLE_DRIVER)
 				return result;
 		}
 	}
+	return result;
+}
+
+VkResult radv_EnumeratePhysicalDevices(
+	VkInstance                                  _instance,
+	uint32_t*                                   pPhysicalDeviceCount,
+	VkPhysicalDevice*                           pPhysicalDevices)
+{
+	RADV_FROM_HANDLE(radv_instance, instance, _instance);
+	VkResult result;
+
+	if (instance->physicalDeviceCount < 0) {
+		result = radv_enumerate_devices(instance);
+		if (result != VK_SUCCESS &&
+		    result != VK_ERROR_INCOMPATIBLE_DRIVER)
+			return result;
+	}
 
 	if (!pPhysicalDevices) {
 		*pPhysicalDeviceCount = instance->physicalDeviceCount;
-- 
2.12.0

