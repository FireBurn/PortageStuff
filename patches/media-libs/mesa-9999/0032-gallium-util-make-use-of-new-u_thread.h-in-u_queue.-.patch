From 70ae7a3afd7ccca5f8be136926d4de7ebf1a1963 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 8 Mar 2017 15:36:33 +1100
Subject: [PATCH 32/36] gallium/util: make use of new u_thread.h in u_queue.{c,
 h}

---
 src/gallium/auxiliary/util/u_queue.c | 6 +++---
 src/gallium/auxiliary/util/u_queue.h | 4 +++-
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_queue.c b/src/gallium/auxiliary/util/u_queue.c
index e0ec290f23..0519667418 100644
--- a/src/gallium/auxiliary/util/u_queue.c
+++ b/src/gallium/auxiliary/util/u_queue.c
@@ -144,7 +144,7 @@ util_queue_thread_func(void *input)
    if (queue->name) {
       char name[16];
       util_snprintf(name, sizeof(name), "%s:%i", queue->name, thread_index);
-      pipe_thread_setname(name);
+      u_thread_setname(name);
    }
 
    while (1) {
@@ -226,7 +226,7 @@ util_queue_init(struct util_queue *queue,
       input->queue = queue;
       input->thread_index = i;
 
-      queue->threads[i] = pipe_thread_create(util_queue_thread_func, input);
+      queue->threads[i] = u_thread_create(util_queue_thread_func, input);
 
       if (!queue->threads[i]) {
          free(input);
@@ -327,5 +327,5 @@ util_queue_get_thread_time_nano(struct util_queue *queue, unsigned thread_index)
    if (thread_index >= queue->num_threads)
       return 0;
 
-   return pipe_thread_get_time_nano(queue->threads[thread_index]);
+   return u_thread_get_time_nano(queue->threads[thread_index]);
 }
diff --git a/src/gallium/auxiliary/util/u_queue.h b/src/gallium/auxiliary/util/u_queue.h
index d62d87d14d..0073890cf3 100644
--- a/src/gallium/auxiliary/util/u_queue.h
+++ b/src/gallium/auxiliary/util/u_queue.h
@@ -33,8 +33,10 @@
 #ifndef U_QUEUE_H
 #define U_QUEUE_H
 
-#include "os/os_thread.h"
+#include <string.h>
+
 #include "util/list.h"
+#include "util/u_thread.h"
 
 /* Job completion fence.
  * Put this into your job structure.
-- 
2.12.0

