From 66142a2cd00e42b0758e0c7d1a7c66cecfd7aa14 Mon Sep 17 00:00:00 2001
From: Friedrich Vock <friedrich.vock@gmx.de>
Date: Thu, 8 Dec 2022 21:26:28 +0100
Subject: [PATCH 1/7] nir: Do not consider phis with incompatible dests equal

CSE tries to collapse equal instructions, and collapsing two phis with incompatible dests is illegal.

Reviewed-by: Konstantin Seurer <konstantin.seurer@gmail.com>
---
 src/compiler/nir/nir_instr_set.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/compiler/nir/nir_instr_set.c b/src/compiler/nir/nir_instr_set.c
index 032fcbcb9189..8f2df2e2c5c3 100644
--- a/src/compiler/nir/nir_instr_set.c
+++ b/src/compiler/nir/nir_instr_set.c
@@ -707,6 +707,11 @@ nir_instrs_equal(const nir_instr *instr1, const nir_instr *instr2)
       if (phi1->instr.block != phi2->instr.block)
          return false;
 
+      if (phi1->dest.ssa.num_components != phi2->dest.ssa.num_components)
+         return false;
+      if (phi1->dest.ssa.bit_size != phi2->dest.ssa.bit_size)
+         return false;
+
       nir_foreach_phi_src(src1, phi1) {
          nir_foreach_phi_src(src2, phi2) {
             if (src1->pred == src2->pred) {
-- 
GitLab


From 1463f526f3ff12799162712b1cd2c71dfaf6e86d Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Fri, 9 Dec 2022 08:16:34 +0100
Subject: [PATCH 2/7] radv/rt: Work around incorrect NOT_DEFERRED handling in
 Portal RTX

Allows Portal RTX to reach the main menu.
---
 src/amd/vulkan/radv_pipeline_rt.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline_rt.c b/src/amd/vulkan/radv_pipeline_rt.c
index aac5d7a60bb0..68a8212e8c1e 100644
--- a/src/amd/vulkan/radv_pipeline_rt.c
+++ b/src/amd/vulkan/radv_pipeline_rt.c
@@ -418,8 +418,9 @@ radv_CreateRayTracingPipelinesKHR(VkDevice _device, VkDeferredOperationKHR defer
    for (; i < count; ++i)
       pPipelines[i] = VK_NULL_HANDLE;
 
+   /* Work around Portal RTX not handling VK_OPERATION_NOT_DEFERRED_KHR correctly. */
    if (result == VK_SUCCESS && deferredOperation != VK_NULL_HANDLE)
-      return VK_OPERATION_NOT_DEFERRED_KHR;
+      return VK_OPERATION_DEFERRED_KHR;
 
    return result;
 }
-- 
GitLab


From 70f65bbc4a49fc2fd87d462c97a511471ae40260 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 10 Dec 2022 12:36:13 +0100
Subject: [PATCH 3/7] radv/rt: Propagate radv_pipeline_key

---
 src/amd/vulkan/radv_pipeline_rt.c |  2 +-
 src/amd/vulkan/radv_rt_shader.c   | 39 ++++++++++++++++---------------
 src/amd/vulkan/radv_shader.c      |  2 +-
 src/amd/vulkan/radv_shader.h      |  3 ++-
 4 files changed, 24 insertions(+), 22 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline_rt.c b/src/amd/vulkan/radv_pipeline_rt.c
index 68a8212e8c1e..f9c8cbf071cf 100644
--- a/src/amd/vulkan/radv_pipeline_rt.c
+++ b/src/amd/vulkan/radv_pipeline_rt.c
@@ -321,7 +321,7 @@ radv_rt_pipeline_create(VkDevice _device, VkPipelineCache _cache,
          goto pipeline_fail;
       }
 
-      shader = create_rt_shader(device, &local_create_info, rt_pipeline->stack_sizes);
+      shader = create_rt_shader(device, &local_create_info, rt_pipeline->stack_sizes, &key);
       module.nir = shader;
       result = radv_create_shaders(&rt_pipeline->base.base, pipeline_layout, device, cache, &key,
                                    &stage, 1, pCreateInfo->flags, hash, creation_feedback,
diff --git a/src/amd/vulkan/radv_rt_shader.c b/src/amd/vulkan/radv_rt_shader.c
index 36834fdf57ab..9e8a145084d0 100644
--- a/src/amd/vulkan/radv_rt_shader.c
+++ b/src/amd/vulkan/radv_rt_shader.c
@@ -96,6 +96,7 @@ lower_rt_derefs(nir_shader *shader)
  */
 struct rt_variables {
    const VkRayTracingPipelineCreateInfoKHR *create_info;
+   const struct radv_pipeline_key *key;
 
    /* idx of the next shader to run in the next iteration of the main loop.
     * During traversal, idx is used to store the SBT index and will contain
@@ -157,10 +158,12 @@ reserve_stack_size(struct rt_variables *vars, uint32_t size)
 
 static struct rt_variables
 create_rt_variables(nir_shader *shader, const VkRayTracingPipelineCreateInfoKHR *create_info,
-                    struct radv_pipeline_shader_stack_size *stack_sizes)
+                    struct radv_pipeline_shader_stack_size *stack_sizes,
+                    const struct radv_pipeline_key *key)
 {
    struct rt_variables vars = {
       .create_info = create_info,
+      .key = key,
    };
    vars.idx = nir_variable_create(shader, nir_var_shader_temp, glsl_uint_type(), "idx");
    vars.arg = nir_variable_create(shader, nir_var_shader_temp, glsl_uint_type(), "arg");
@@ -665,7 +668,8 @@ insert_rt_case(nir_builder *b, nir_shader *shader, struct rt_variables *vars, ni
 
    nir_opt_dead_cf(shader);
 
-   struct rt_variables src_vars = create_rt_variables(shader, vars->create_info, vars->stack_sizes);
+   struct rt_variables src_vars =
+      create_rt_variables(shader, vars->create_info, vars->stack_sizes, vars->key);
    map_rt_variables(var_remap, &src_vars, vars);
 
    NIR_PASS_V(shader, lower_rt_instructions, &src_vars, call_idx_base);
@@ -687,16 +691,14 @@ insert_rt_case(nir_builder *b, nir_shader *shader, struct rt_variables *vars, ni
 }
 
 static nir_shader *
-parse_rt_stage(struct radv_device *device, const VkPipelineShaderStageCreateInfo *sinfo)
+parse_rt_stage(struct radv_device *device, const VkPipelineShaderStageCreateInfo *sinfo,
+               const struct radv_pipeline_key *key)
 {
-   struct radv_pipeline_key key;
-   memset(&key, 0, sizeof(key));
-
    struct radv_pipeline_stage rt_stage;
 
    radv_pipeline_stage_init(sinfo, &rt_stage, vk_to_mesa_shader_stage(sinfo->stage));
 
-   nir_shader *shader = radv_shader_spirv_to_nir(device, &rt_stage, &key);
+   nir_shader *shader = radv_shader_spirv_to_nir(device, &rt_stage, key);
 
    if (shader->info.stage == MESA_SHADER_RAYGEN || shader->info.stage == MESA_SHADER_CLOSEST_HIT ||
        shader->info.stage == MESA_SHADER_CALLABLE || shader->info.stage == MESA_SHADER_MISS) {
@@ -991,7 +993,7 @@ visit_any_hit_shaders(struct radv_device *device,
          continue;
 
       const VkPipelineShaderStageCreateInfo *stage = &pCreateInfo->pStages[shader_id];
-      nir_shader *nir_stage = parse_rt_stage(device, stage);
+      nir_shader *nir_stage = parse_rt_stage(device, stage, vars->key);
 
       vars->stage_idx = shader_id;
       insert_rt_case(b, nir_stage, vars, sbt_idx, 0, i + 2);
@@ -1122,12 +1124,12 @@ handle_candidate_aabb(nir_builder *b, struct radv_leaf_intersection *intersectio
          continue;
 
       const VkPipelineShaderStageCreateInfo *stage = &data->createInfo->pStages[shader_id];
-      nir_shader *nir_stage = parse_rt_stage(data->device, stage);
+      nir_shader *nir_stage = parse_rt_stage(data->device, stage, data->vars->key);
 
       nir_shader *any_hit_stage = NULL;
       if (any_hit_shader_id != VK_SHADER_UNUSED_KHR) {
          stage = &data->createInfo->pStages[any_hit_shader_id];
-         any_hit_stage = parse_rt_stage(data->device, stage);
+         any_hit_stage = parse_rt_stage(data->device, stage, data->vars->key);
 
          nir_lower_intersection_shader(nir_stage, any_hit_stage);
          ralloc_free(any_hit_stage);
@@ -1177,7 +1179,8 @@ load_stack_entry(nir_builder *b, nir_ssa_def *index, const struct radv_ray_trave
 static nir_shader *
 build_traversal_shader(struct radv_device *device,
                        const VkRayTracingPipelineCreateInfoKHR *pCreateInfo,
-                       struct radv_pipeline_shader_stack_size *stack_sizes)
+                       struct radv_pipeline_shader_stack_size *stack_sizes,
+                       const struct radv_pipeline_key *key)
 {
    nir_builder b = radv_meta_init_shader(device, MESA_SHADER_COMPUTE, "rt_traversal");
    b.shader->info.internal = false;
@@ -1185,7 +1188,7 @@ build_traversal_shader(struct radv_device *device,
    b.shader->info.workgroup_size[1] = device->physical_device->rt_wave_size == 64 ? 8 : 4;
    b.shader->info.shared_size =
       device->physical_device->rt_wave_size * MAX_STACK_ENTRY_COUNT * sizeof(uint32_t);
-   struct rt_variables vars = create_rt_variables(b.shader, pCreateInfo, stack_sizes);
+   struct rt_variables vars = create_rt_variables(b.shader, pCreateInfo, stack_sizes, key);
 
    /* initialize trace_ray arguments */
    nir_ssa_def *accel_struct = nir_load_accel_struct_amd(&b);
@@ -1411,17 +1414,15 @@ move_rt_instructions(nir_shader *shader)
 
 nir_shader *
 create_rt_shader(struct radv_device *device, const VkRayTracingPipelineCreateInfoKHR *pCreateInfo,
-                 struct radv_pipeline_shader_stack_size *stack_sizes)
+                 struct radv_pipeline_shader_stack_size *stack_sizes,
+                 const struct radv_pipeline_key *key)
 {
-   struct radv_pipeline_key key;
-   memset(&key, 0, sizeof(key));
-
    nir_builder b = radv_meta_init_shader(device, MESA_SHADER_COMPUTE, "rt_combined");
    b.shader->info.internal = false;
    b.shader->info.workgroup_size[0] = 8;
    b.shader->info.workgroup_size[1] = device->physical_device->rt_wave_size == 64 ? 8 : 4;
 
-   struct rt_variables vars = create_rt_variables(b.shader, pCreateInfo, stack_sizes);
+   struct rt_variables vars = create_rt_variables(b.shader, pCreateInfo, stack_sizes, key);
    load_sbt_entry(&b, &vars, nir_imm_int(&b, 0), SBT_RAYGEN, SBT_GENERAL_IDX);
    if (radv_rt_pipeline_has_dynamic_stack_size(pCreateInfo))
       nir_store_var(&b, vars.stack_ptr, nir_load_rt_dynamic_callable_stack_base_amd(&b), 0x1);
@@ -1437,7 +1438,7 @@ create_rt_shader(struct radv_device *device, const VkRayTracingPipelineCreateInf
    nir_ssa_def *idx = nir_load_var(&b, vars.idx);
 
    /* Insert traversal shader */
-   nir_shader *traversal = build_traversal_shader(device, pCreateInfo, stack_sizes);
+   nir_shader *traversal = build_traversal_shader(device, pCreateInfo, stack_sizes, key);
    assert(b.shader->info.shared_size == 0);
    b.shader->info.shared_size = traversal->info.shared_size;
    assert(b.shader->info.shared_size <= 32768);
@@ -1454,7 +1455,7 @@ create_rt_shader(struct radv_device *device, const VkRayTracingPipelineCreateInf
           type != MESA_SHADER_CLOSEST_HIT && type != MESA_SHADER_MISS)
          continue;
 
-      nir_shader *nir_stage = parse_rt_stage(device, stage);
+      nir_shader *nir_stage = parse_rt_stage(device, stage, key);
 
       /* Move ray tracing system values to the top that are set by rt_trace_ray
        * to prevent them from being overwritten by other rt_trace_ray calls.
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 598279abc0b6..d78ef60e9e72 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -723,7 +723,7 @@ radv_shader_spirv_to_nir(struct radv_device *device, const struct radv_pipeline_
       /* Only compute shaders currently support requiring a
        * specific subgroup size.
        */
-      assert(stage->stage == MESA_SHADER_COMPUTE);
+      assert(stage->stage >= MESA_SHADER_COMPUTE);
       subgroup_size = key->cs.compute_subgroup_size;
       ballot_bit_size = key->cs.compute_subgroup_size;
    }
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 1723ba4bd36d..062fe173f4f5 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -754,6 +754,7 @@ bool radv_lower_fs_intrinsics(nir_shader *nir, const struct radv_pipeline_stage
 
 nir_shader *create_rt_shader(struct radv_device *device,
                              const VkRayTracingPipelineCreateInfoKHR *pCreateInfo,
-                             struct radv_pipeline_shader_stack_size *stack_sizes);
+                             struct radv_pipeline_shader_stack_size *stack_sizes,
+                             const struct radv_pipeline_key *key);
 
 #endif
-- 
GitLab


From 478cfd96c5bb7f5650a4898b9631a9371a0d3ab4 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 10 Dec 2022 13:13:09 +0100
Subject: [PATCH 4/7] radv/rt: Hash the pipeline key

---
 src/amd/vulkan/radv_pipeline_cache.c | 4 +++-
 src/amd/vulkan/radv_pipeline_rt.c    | 4 +++-
 src/amd/vulkan/radv_private.h        | 2 +-
 3 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline_cache.c b/src/amd/vulkan/radv_pipeline_cache.c
index 081ce4d1a825..14acb697713c 100644
--- a/src/amd/vulkan/radv_pipeline_cache.c
+++ b/src/amd/vulkan/radv_pipeline_cache.c
@@ -153,7 +153,7 @@ radv_hash_shaders(unsigned char *hash, const struct radv_pipeline_stage *stages,
 
 void
 radv_hash_rt_shaders(unsigned char *hash, const VkRayTracingPipelineCreateInfoKHR *pCreateInfo,
-                     uint32_t flags)
+                     const struct radv_pipeline_key *key, uint32_t flags)
 {
    RADV_FROM_HANDLE(radv_pipeline_layout, layout, pCreateInfo->layout);
    struct mesa_sha1 ctx;
@@ -162,6 +162,8 @@ radv_hash_rt_shaders(unsigned char *hash, const VkRayTracingPipelineCreateInfoKH
    if (layout)
       _mesa_sha1_update(&ctx, layout->sha1, sizeof(layout->sha1));
 
+   _mesa_sha1_update(&ctx, key, sizeof(*key));
+
    for (uint32_t i = 0; i < pCreateInfo->stageCount; ++i) {
       RADV_FROM_HANDLE(vk_shader_module, module, pCreateInfo->pStages[i].module);
       const VkSpecializationInfo *spec_info = pCreateInfo->pStages[i].pSpecializationInfo;
diff --git a/src/amd/vulkan/radv_pipeline_rt.c b/src/amd/vulkan/radv_pipeline_rt.c
index f9c8cbf071cf..d11b2995446d 100644
--- a/src/amd/vulkan/radv_pipeline_rt.c
+++ b/src/amd/vulkan/radv_pipeline_rt.c
@@ -272,7 +272,6 @@ radv_rt_pipeline_create(VkDevice _device, VkPipelineCache _cache,
       goto fail;
    }
 
-   radv_hash_rt_shaders(hash, &local_create_info, radv_get_hash_flags(device, keep_statistic_info));
    struct vk_shader_module module = {.base.type = VK_OBJECT_TYPE_SHADER_MODULE};
 
    VkPipelineShaderStageCreateInfo stage = {
@@ -301,6 +300,9 @@ radv_rt_pipeline_create(VkDevice _device, VkPipelineCache _cache,
    struct radv_pipeline_key key = radv_generate_rt_pipeline_key(rt_pipeline, pCreateInfo->flags);
    UNUSED gl_shader_stage last_vgt_api_stage = MESA_SHADER_NONE;
 
+   radv_hash_rt_shaders(hash, &local_create_info, &key,
+                        radv_get_hash_flags(device, keep_statistic_info));
+
    /* First check if we can get things from the cache before we take the expensive step of
     * generating the nir. */
    result = radv_create_shaders(
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 795eb5d62846..0d43cb68d9d9 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1965,7 +1965,7 @@ void radv_hash_shaders(unsigned char *hash, const struct radv_pipeline_stage *st
                        const struct radv_pipeline_key *key, uint32_t flags);
 
 void radv_hash_rt_shaders(unsigned char *hash, const VkRayTracingPipelineCreateInfoKHR *pCreateInfo,
-                          uint32_t flags);
+                          const struct radv_pipeline_key *key, uint32_t flags);
 
 uint32_t radv_get_hash_flags(const struct radv_device *device, bool stats);
 
-- 
GitLab


From 0ddcee02f96bf721e996ba94e46055112475184c Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 10 Dec 2022 12:36:57 +0100
Subject: [PATCH 5/7] spirv: Add a debug option to force non uniform texture
 sampling

Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
---
 src/compiler/spirv/nir_spirv.h    | 3 +++
 src/compiler/spirv/spirv_to_nir.c | 3 +++
 2 files changed, 6 insertions(+)

diff --git a/src/compiler/spirv/nir_spirv.h b/src/compiler/spirv/nir_spirv.h
index 765a005e1b82..5c28bc2f093a 100644
--- a/src/compiler/spirv/nir_spirv.h
+++ b/src/compiler/spirv/nir_spirv.h
@@ -110,6 +110,9 @@ struct spirv_to_nir_options {
                    const char *message);
       void *private_data;
    } debug;
+
+   /* Force texture sampling to be non-uniform. */
+   bool force_tex_non_uniform;
 };
 
 bool gl_spirv_validation(const uint32_t *words, size_t word_count,
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index 41adaa14ae3b..5f6022740139 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -3104,6 +3104,9 @@ vtn_handle_texture(struct vtn_builder *b, SpvOp opcode,
    if (operands & SpvImageOperandsNontemporalMask)
       access |= ACCESS_STREAM_CACHE_POLICY;
 
+   if (sampler && b->options->force_tex_non_uniform)
+      access |= ACCESS_NON_UNIFORM;
+
    if (sampled_val->propagated_non_uniform)
       access |= ACCESS_NON_UNIFORM;
 
-- 
GitLab


From 9aa1be9a35fa7b98cc2e9aa36f8d3bda3c118f7e Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 10 Dec 2022 12:37:56 +0100
Subject: [PATCH 6/7] radv: Add a driconf option to force non uniform texture
 sampling

---
 src/amd/vulkan/radv_device.c   | 3 +++
 src/amd/vulkan/radv_pipeline.c | 2 ++
 src/amd/vulkan/radv_private.h  | 1 +
 src/amd/vulkan/radv_shader.c   | 1 +
 src/amd/vulkan/radv_shader.h   | 1 +
 src/util/driconf.h             | 4 ++++
 6 files changed, 12 insertions(+)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index caa7a318cd3d..db6cd023302b 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1144,6 +1144,7 @@ static const driOptionDescription radv_dri_options[] = {
       DRI_CONF_RADV_DGC(false)
       DRI_CONF_RADV_FLUSH_BEFORE_QUERY_COPY(false)
       DRI_CONF_RADV_ENABLE_UNIFIED_HEAP_ON_APU(false)
+      DRI_CONF_RADV_TEX_NON_UNIFORM(false)
    DRI_CONF_SECTION_END
 };
 // clang-format on
@@ -1198,6 +1199,8 @@ radv_init_dri_options(struct radv_instance *instance)
 
    instance->enable_unified_heap_on_apu =
       driQueryOptionb(&instance->dri_options, "radv_enable_unified_heap_on_apu");
+
+   instance->tex_non_uniform = driQueryOptionb(&instance->dri_options, "radv_tex_non_uniform");
 }
 
 static VkResult create_null_physical_device(struct vk_instance *vk_instance);
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 2de3f2376d80..4c8e2a9168dd 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2674,6 +2674,8 @@ radv_generate_pipeline_key(const struct radv_pipeline *pipeline, VkPipelineCreat
    key.image_2d_view_of_3d = device->image_2d_view_of_3d &&
                              device->physical_device->rad_info.gfx_level == GFX9;
 
+   key.tex_non_uniform = device->instance->tex_non_uniform;
+
    return key;
 }
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 0d43cb68d9d9..19c6f4151739 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -369,6 +369,7 @@ struct radv_instance {
    bool disable_sinking_load_input_fs;
    bool flush_before_query_copy;
    bool enable_unified_heap_on_apu;
+   bool tex_non_uniform;
 };
 
 VkResult radv_init_wsi(struct radv_physical_device *physical_device);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index d78ef60e9e72..83bc7abc91f6 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -834,6 +834,7 @@ radv_shader_spirv_to_nir(struct radv_device *device, const struct radv_pipeline_
                .func = radv_spirv_nir_debug,
                .private_data = &spirv_debug_data,
             },
+         .force_tex_non_uniform = key->tex_non_uniform,
       };
       nir = spirv_to_nir(spirv, stage->spirv.size / 4, spec_entries, num_spec_entries, stage->stage,
                          stage->entrypoint, &spirv_options,
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 062fe173f4f5..ad5de84154e8 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -77,6 +77,7 @@ struct radv_pipeline_key {
    uint32_t dynamic_rasterization_samples : 1;
    uint32_t dynamic_color_write_mask : 1;
    uint32_t dynamic_provoking_vtx_mode : 1;
+   uint32_t tex_non_uniform : 1;
 
    struct {
       uint32_t instance_rate_inputs;
diff --git a/src/util/driconf.h b/src/util/driconf.h
index 8fb89cacdb78..1df74c702608 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -595,6 +595,10 @@
    DRI_CONF_OPT_B(radv_enable_unified_heap_on_apu, def, \
                   "Enable an unified heap with DEVICE_LOCAL on integrated GPUs")
 
+#define DRI_CONF_RADV_TEX_NON_UNIFORM(def) \
+   DRI_CONF_OPT_B(radv_tex_non_uniform, def, \
+                  "Always mark texture sample operations as non-uniform.")
+
 /**
  * \brief ANV specific configuration options
  */
-- 
GitLab


From 2ad105547431bb66cc896383bb601cce91f6ffa9 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 10 Dec 2022 12:38:24 +0100
Subject: [PATCH 7/7] radv: Force non uniform texture sampling with NV Remix

---
 src/util/00-radv-defaults.conf | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/util/00-radv-defaults.conf b/src/util/00-radv-defaults.conf
index 0ede6ef321c4..12e665c2e788 100644
--- a/src/util/00-radv-defaults.conf
+++ b/src/util/00-radv-defaults.conf
@@ -56,6 +56,10 @@ Application bugs worked around in this file:
             <option name="radv_flush_before_query_copy" value="true" />
         </engine>
 
+        <engine engine_name_match="DXVK_NvRemix">
+            <option name="radv_tex_non_uniform" value="true" />
+        </engine>
+
         <!-- Game workarounds -->
         <application name="Shadow Of The Tomb Raider (Native)" application_name_match="ShadowOfTheTomb">
             <option name="radv_report_llvm9_version_string" value="true" />
-- 
GitLab

