From 978ae96c6f6c9300ea455b30a02f43da22574fd7 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 25 Nov 2021 10:10:09 +0100
Subject: [PATCH 1/5] vk: allocate the DRI_PRIME linear buffer on the display
 gpu

---
 src/amd/vulkan/radv_wsi.c           | 36 ++++++++++++++
 src/vulkan/wsi/wsi_common.h         |  2 +
 src/vulkan/wsi/wsi_common_drm.c     | 73 +++++++++++++++++++++++------
 src/vulkan/wsi/wsi_common_private.h |  1 +
 src/vulkan/wsi/wsi_common_x11.c     | 17 ++++++-
 5 files changed, 113 insertions(+), 16 deletions(-)

diff --git a/src/amd/vulkan/radv_wsi.c b/src/amd/vulkan/radv_wsi.c
index a8e79585969..2b237cdc0f7 100644
--- a/src/amd/vulkan/radv_wsi.c
+++ b/src/amd/vulkan/radv_wsi.c
@@ -24,6 +24,7 @@
  */
 
 #include "util/macros.h"
+#include "util/os_file.h"
 #include "radv_meta.h"
 #include "radv_private.h"
 #include "vk_util.h"
@@ -47,6 +48,40 @@ radv_wsi_set_memory_ownership(VkDevice _device, VkDeviceMemory _mem, VkBool32 ow
    }
 }
 
+static VkResult
+radv_wsi_create_device_for_fd(VkDevice _device, int fd, VkDevice *display_dev)
+{
+   RADV_FROM_HANDLE(radv_device, device, _device);
+   assert(device->instance->physical_devices_enumerated);
+   list_for_each_entry(struct radv_physical_device, pdevice, &device->instance->physical_devices, link)
+   {
+      if (os_same_file_description(fd, pdevice->local_fd)) {
+         float queuePriority = 1.0f;
+         VkPhysicalDeviceFeatures features = { 0 };
+
+         VkDeviceQueueCreateInfo queue = {
+            .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
+            .queueCount = 1,
+            .queueFamilyIndex = 0,
+            .pQueuePriorities = &queuePriority,
+         };
+
+         VkDeviceCreateInfo info = {
+            .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
+            .queueCreateInfoCount = 1,
+            .pQueueCreateInfos = &queue,
+            .pEnabledFeatures = &features,
+            .enabledExtensionCount = 0,
+            .enabledLayerCount = 0,
+         };
+
+         return radv_CreateDevice(radv_physical_device_to_handle(pdevice), &info, NULL, display_dev);
+      }
+   }
+   return VK_ERROR_UNKNOWN;
+}
+
+
 VkResult
 radv_init_wsi(struct radv_physical_device *physical_device)
 {
@@ -59,6 +94,7 @@ radv_init_wsi(struct radv_physical_device *physical_device)
 
    physical_device->wsi_device.supports_modifiers = physical_device->rad_info.chip_class >= GFX9;
    physical_device->wsi_device.set_memory_ownership = radv_wsi_set_memory_ownership;
+   physical_device->wsi_device.create_device_for_fd = radv_wsi_create_device_for_fd;
 
    wsi_device_setup_syncobj_fd(&physical_device->wsi_device, physical_device->local_fd);
 
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 63f21ef698b..29dfdb779aa 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -171,6 +171,8 @@ struct wsi_device {
     */
    bool (*can_present_on_device)(VkPhysicalDevice pdevice, int fd);
 
+   VkResult (*create_device_for_fd)(VkDevice pdevice, int fd, VkDevice *display_dev);
+
 #define WSI_CB(cb) PFN_vk##cb cb
    WSI_CB(AllocateMemory);
    WSI_CB(AllocateCommandBuffers);
diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index 09684b2272d..6b0201d264d 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -463,6 +463,7 @@ wsi_create_prime_image(const struct wsi_swapchain *chain,
                        struct wsi_image *image)
 {
    const struct wsi_device *wsi = chain->wsi;
+   VkDevice display_device = chain->device;
    VkResult result;
 
    memset(image, 0, sizeof(*image));
@@ -486,13 +487,23 @@ wsi_create_prime_image(const struct wsi_swapchain *chain,
       .usage = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
       .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    };
-   result = wsi->CreateBuffer(chain->device, &prime_buffer_info,
+
+   if (chain->display_fd > 0 && wsi->create_device_for_fd) {
+      if (wsi->create_device_for_fd(chain->device, chain->display_fd, &display_device) != VK_SUCCESS) {
+         struct wsi_swapchain copy = *chain;
+         copy.display_fd = -1;
+         return wsi_create_prime_image(&copy, pCreateInfo, use_modifier, image);
+      }
+   }
+
+   result = wsi->CreateBuffer(display_device, &prime_buffer_info,
                               &chain->alloc, &image->prime.buffer);
+
    if (result != VK_SUCCESS)
       goto fail;
 
    VkMemoryRequirements reqs;
-   wsi->GetBufferMemoryRequirements(chain->device, image->prime.buffer, &reqs);
+   wsi->GetBufferMemoryRequirements(display_device, image->prime.buffer, &reqs);
    assert(reqs.size <= linear_size);
 
    const struct wsi_memory_allocate_info memory_wsi_info = {
@@ -515,13 +526,45 @@ wsi_create_prime_image(const struct wsi_swapchain *chain,
       .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
       .pNext = &prime_memory_dedicated_info,
       .allocationSize = linear_size,
-      .memoryTypeIndex = select_memory_type(wsi, false, reqs.memoryTypeBits),
+      /* When allocating directly on the display device, we want a DEVICE_LOCAL
+       * allocation so it's scanout-compatible.
+       */
+      .memoryTypeIndex = select_memory_type(wsi, display_device != chain->device, reqs.memoryTypeBits),
    };
-   result = wsi->AllocateMemory(chain->device, &prime_memory_info,
+   result = wsi->AllocateMemory(display_device, &prime_memory_info,
                                 &chain->alloc, &image->prime.memory);
    if (result != VK_SUCCESS)
       goto fail;
 
+   int fd;
+   if (display_device != chain->device) {
+      /* Export */
+      const VkMemoryGetFdInfoKHR info = {
+         .sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
+         .memory = image->prime.memory,
+         .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
+      };
+      result = wsi->GetMemoryFdKHR(display_device, &info, &fd);
+      assert(result == VK_SUCCESS);
+
+      /* Import */
+      const VkImportMemoryFdInfoKHR prime_memory_import_info = {
+         .sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
+         .fd = fd,
+         .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
+      };
+      const VkMemoryAllocateInfo prime_memory_info = {
+         .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
+         .pNext = &prime_memory_import_info,
+         .allocationSize = linear_size,
+      };
+
+      result = wsi->AllocateMemory(chain->device, &prime_memory_info,
+                                   &chain->alloc, &image->prime.memory);
+
+      assert(result == VK_SUCCESS);
+   }
+
    result = wsi->BindBufferMemory(chain->device, image->prime.buffer,
                                   image->prime.memory, 0);
    if (result != VK_SUCCESS)
@@ -636,16 +679,18 @@ wsi_create_prime_image(const struct wsi_swapchain *chain,
          goto fail;
    }
 
-   const VkMemoryGetFdInfoKHR linear_memory_get_fd_info = {
-      .sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
-      .pNext = NULL,
-      .memory = image->prime.memory,
-      .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
-   };
-   int fd;
-   result = wsi->GetMemoryFdKHR(chain->device, &linear_memory_get_fd_info, &fd);
-   if (result != VK_SUCCESS)
-      goto fail;
+   if (display_device != chain->device) {
+      const VkMemoryGetFdInfoKHR linear_memory_get_fd_info = {
+         .sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
+         .pNext = NULL,
+         .memory = image->prime.memory,
+         .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
+      };
+
+      result = wsi->GetMemoryFdKHR(chain->device, &linear_memory_get_fd_info, &fd);
+      if (result != VK_SUCCESS)
+         goto fail;
+   }
 
    image->drm_modifier = use_modifier ? DRM_FORMAT_MOD_LINEAR : DRM_FORMAT_MOD_INVALID;
    image->num_planes = 1;
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 3eb14d22f9e..7fe2cd8cca2 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -56,6 +56,7 @@ struct wsi_swapchain {
    uint32_t image_count;
 
    bool use_prime_blit;
+   int display_fd;
 
    /* Command pools, one per queue family */
    VkCommandPool *cmd_pools;
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index de9794cd1f0..9dba416add8 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1799,10 +1799,23 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
     */
    chain->copy_is_suboptimal = false;
 
-   if (!wsi_device->sw)
-      if (!wsi_x11_check_dri3_compatible(wsi_device, conn))
+   if (!wsi_device->sw) {
+      if (!wsi_x11_check_dri3_compatible(wsi_device, conn)) {
          chain->base.use_prime_blit = true;
 
+         /* Get display GPU fd through X11 connection */
+         xcb_screen_iterator_t screen_iter =
+            xcb_setup_roots_iterator(xcb_get_setup(chain->conn));
+         xcb_screen_t *screen = screen_iter.data;
+         int dri3_fd = wsi_dri3_open(chain->conn, screen->root, None);
+
+         /* Try to create a wsi_device for this fd */
+         if (wsi_device->create_device_for_fd) {
+            chain->base.display_fd = dri3_fd;
+         }
+      }
+   }
+
    chain->event_id = xcb_generate_id(chain->conn);
    xcb_present_select_input(chain->conn, chain->event_id, chain->window,
                             XCB_PRESENT_EVENT_MASK_CONFIGURE_NOTIFY |
-- 
GitLab


From 54d091b2eaa40c4123eb419faeca90361a39e5dc Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 25 Nov 2021 13:56:29 +0100
Subject: [PATCH 2/5] radv: import DRI_PRIME linear buffer as non-cached

Based on https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/13362
---
 src/amd/vulkan/radv_android.c                 | 2 +-
 src/amd/vulkan/radv_device.c                  | 2 +-
 src/amd/vulkan/radv_radeon_winsys.h           | 3 ++-
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c | 7 ++++---
 src/vulkan/wsi/wsi_common_drm.c               | 3 ++-
 5 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/amd/vulkan/radv_android.c b/src/amd/vulkan/radv_android.c
index d26095de714..f52859be65c 100644
--- a/src/amd/vulkan/radv_android.c
+++ b/src/amd/vulkan/radv_android.c
@@ -838,7 +838,7 @@ radv_import_ahb_memory(struct radv_device *device, struct radv_device_memory *me
 
    uint64_t alloc_size = 0;
    VkResult result =
-      device->ws->buffer_from_fd(device->ws, dma_buf, priority, &mem->bo, &alloc_size);
+      device->ws->buffer_from_fd(device->ws, dma_buf, priority, &mem->bo, &alloc_size, false);
    if (result != VK_SUCCESS)
       return result;
 
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 7f4604c2baf..c2eb157f635 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -5314,7 +5314,7 @@ radv_alloc_memory(struct radv_device *device, const VkMemoryAllocateInfo *pAlloc
    } else if (import_info) {
       assert(import_info->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT ||
              import_info->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
-      result = device->ws->buffer_from_fd(device->ws, import_info->fd, priority, &mem->bo, NULL);
+      result = device->ws->buffer_from_fd(device->ws, import_info->fd, priority, &mem->bo, NULL, wsi_info != NULL);
       if (result != VK_SUCCESS) {
          goto fail;
       } else {
diff --git a/src/amd/vulkan/radv_radeon_winsys.h b/src/amd/vulkan/radv_radeon_winsys.h
index 9f12b6040c3..3acd7eca73d 100644
--- a/src/amd/vulkan/radv_radeon_winsys.h
+++ b/src/amd/vulkan/radv_radeon_winsys.h
@@ -234,7 +234,8 @@ struct radeon_winsys {
                                unsigned priority, struct radeon_winsys_bo **out_bo);
 
    VkResult (*buffer_from_fd)(struct radeon_winsys *ws, int fd, unsigned priority,
-                              struct radeon_winsys_bo **out_bo, uint64_t *alloc_size);
+                              struct radeon_winsys_bo **out_bo, uint64_t *alloc_size,
+                              bool is_prime_linear_buffer);
 
    bool (*buffer_get_fd)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, int *fd);
 
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
index 3bea2f38028..a9e63c47198 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
@@ -696,7 +696,8 @@ error:
 
 static VkResult
 radv_amdgpu_winsys_bo_from_fd(struct radeon_winsys *_ws, int fd, unsigned priority,
-                              struct radeon_winsys_bo **out_bo, uint64_t *alloc_size)
+                              struct radeon_winsys_bo **out_bo, uint64_t *alloc_size,
+                              bool is_prime_linear_buffer)
 {
    struct radv_amdgpu_winsys *ws = radv_amdgpu_winsys(_ws);
    struct radv_amdgpu_winsys_bo *bo;
@@ -740,8 +741,8 @@ radv_amdgpu_winsys_bo_from_fd(struct radeon_winsys *_ws, int fd, unsigned priori
       goto error_query;
    }
 
-   r =
-      radv_amdgpu_bo_va_op(ws, result.buf_handle, 0, result.alloc_size, va, 0, 0, AMDGPU_VA_OP_MAP);
+   r = radv_amdgpu_bo_va_op(ws, result.buf_handle, 0, result.alloc_size, va,
+                            is_prime_linear_buffer ? RADEON_FLAG_VA_UNCACHED : 0, 0, AMDGPU_VA_OP_MAP);
    if (r) {
       vk_result = VK_ERROR_UNKNOWN;
       goto error_va_map;
diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index 6b0201d264d..a5e64ecb041 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -551,7 +551,8 @@ wsi_create_prime_image(const struct wsi_swapchain *chain,
       const VkImportMemoryFdInfoKHR prime_memory_import_info = {
          .sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
          .fd = fd,
-         .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
+         .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
+         .pNext = &memory_wsi_info,
       };
       const VkMemoryAllocateInfo prime_memory_info = {
          .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
-- 
GitLab


From 15748d46a5f15a9c382ce0aba99455821a2c0e43 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 25 Nov 2021 10:12:56 +0100
Subject: [PATCH 3/5] radv: partial sdma support

SDMA code adapted from https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12763

The only supported use case is image (linear or tiled) -> buffer and only GFX9+ is
supported (for now).

TODO: dcc decompression
---
 src/amd/vulkan/meson.build            |   1 +
 src/amd/vulkan/radv_debug.h           |   1 +
 src/amd/vulkan/radv_device.c          |   5 +
 src/amd/vulkan/radv_private.h         |   3 +
 src/amd/vulkan/radv_sdma_copy_image.c | 192 ++++++++++++++++++++++++++
 5 files changed, 202 insertions(+)
 create mode 100644 src/amd/vulkan/radv_sdma_copy_image.c

diff --git a/src/amd/vulkan/meson.build b/src/amd/vulkan/meson.build
index c5e4bc2e1cd..ed8345cefa1 100644
--- a/src/amd/vulkan/meson.build
+++ b/src/amd/vulkan/meson.build
@@ -75,6 +75,7 @@ libradv_files = files(
   'radv_pipeline_rt.c',
   'radv_private.h',
   'radv_radeon_winsys.h',
+  'radv_sdma_copy_image.c',
   'radv_shader.c',
   'radv_shader.h',
   'radv_shader_args.c',
diff --git a/src/amd/vulkan/radv_debug.h b/src/amd/vulkan/radv_debug.h
index 5c0dd14220e..22abbc3829f 100644
--- a/src/amd/vulkan/radv_debug.h
+++ b/src/amd/vulkan/radv_debug.h
@@ -64,6 +64,7 @@ enum {
    RADV_DEBUG_NO_ATOC_DITHERING = 1ull << 33,
    RADV_DEBUG_NO_NGGC = 1ull << 34,
    RADV_DEBUG_DUMP_PROLOGS = 1ull << 35,
+   RADV_DEBUG_NO_DMA_BLIT = 1ull << 36,
 };
 
 enum {
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index c2eb157f635..a4cb13406e8 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -853,6 +853,7 @@ static const struct debug_control radv_debug_options[] = {
    {"noatocdithering", RADV_DEBUG_NO_ATOC_DITHERING},
    {"nonggc", RADV_DEBUG_NO_NGGC},
    {"prologs", RADV_DEBUG_DUMP_PROLOGS},
+   {"nodma", RADV_DEBUG_NO_DMA_BLIT},
    {NULL, 0}};
 
 const char *
@@ -3060,6 +3061,7 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
       }
 
       memset(device->queues[qfi], 0, queue_create->queueCount * sizeof(struct radv_queue));
+      device->private_sdma_queue = NULL;
 
       device->queue_count[qfi] = queue_create->queueCount;
 
@@ -3760,6 +3762,9 @@ radv_get_preamble_cs(struct radv_queue *queue, uint32_t scratch_size_per_wave,
    unsigned tess_offchip_ring_offset;
    uint32_t ring_bo_flags = RADEON_FLAG_NO_CPU_ACCESS | RADEON_FLAG_NO_INTERPROCESS_SHARING;
    VkResult result = VK_SUCCESS;
+   if (queue->vk.queue_family_index == RADV_QUEUE_TRANSFER)
+      return VK_SUCCESS;
+
    if (!queue->has_tess_rings) {
       if (needs_tess_rings)
          add_tess_rings = true;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 84340806584..cb0994038f7 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -751,6 +751,7 @@ struct radv_device {
    struct radv_meta_state meta_state;
 
    struct radv_queue *queues[RADV_MAX_QUEUE_FAMILIES];
+   struct radv_queue *private_sdma_queue;
    int queue_count[RADV_MAX_QUEUE_FAMILIES];
    struct radeon_cmdbuf *empty_cs[RADV_MAX_QUEUE_FAMILIES];
 
@@ -2669,6 +2670,8 @@ void radv_emit_thread_trace_userdata(const struct radv_device *device, struct ra
                                      const void *data, uint32_t num_dwords);
 bool radv_is_instruction_timing_enabled(void);
 
+bool radv_sdma_copy_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, struct radv_buffer *buffer, const VkBufferImageCopy2KHR *region);
+
 /* radv_sqtt_layer_.c */
 struct radv_barrier_data {
    union {
diff --git a/src/amd/vulkan/radv_sdma_copy_image.c b/src/amd/vulkan/radv_sdma_copy_image.c
new file mode 100644
index 00000000000..c08b41c2117
--- /dev/null
+++ b/src/amd/vulkan/radv_sdma_copy_image.c
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2010 Jerome Glisse <glisse@freedesktop.org>
+ * Copyright 2015-2021 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "radv_cs.h"
+#include "radv_private.h"
+#include "sid.h"
+#include "util/u_memory.h"
+
+
+static
+bool radv_translate_format_to_hw(struct radeon_info *info, VkFormat format, unsigned *hw_fmt, unsigned *hw_type)
+{
+   const struct util_format_description *desc = vk_format_description(format);
+   *hw_fmt = radv_translate_colorformat(format);
+
+   int firstchan;
+   for (firstchan = 0; firstchan < 4; firstchan++) {
+      if (desc->channel[firstchan].type != UTIL_FORMAT_TYPE_VOID) {
+         break;
+      }
+   }
+   if (firstchan == 4 || desc->channel[firstchan].type == UTIL_FORMAT_TYPE_FLOAT) {
+      *hw_type = V_028C70_NUMBER_FLOAT;
+   } else {
+      *hw_type = V_028C70_NUMBER_UNORM;
+      if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB)
+         *hw_type = V_028C70_NUMBER_SRGB;
+      else if (desc->channel[firstchan].type == UTIL_FORMAT_TYPE_SIGNED) {
+         if (desc->channel[firstchan].pure_integer) {
+            *hw_type = V_028C70_NUMBER_SINT;
+         } else {
+            assert(desc->channel[firstchan].normalized);
+            *hw_type = V_028C70_NUMBER_SNORM;
+         }
+      } else if (desc->channel[firstchan].type == UTIL_FORMAT_TYPE_UNSIGNED) {
+         if (desc->channel[firstchan].pure_integer) {
+            *hw_type = V_028C70_NUMBER_UINT;
+         } else {
+            assert(desc->channel[firstchan].normalized);
+            *hw_type = V_028C70_NUMBER_UNORM;
+         }
+      } else {
+         return false;
+      }
+   }
+   return true;
+}
+
+static
+bool radv_sdma_v4_v5_copy_image_to_buffer(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, struct radv_buffer *buffer, const VkBufferImageCopy2KHR *region)
+{
+   assert(image->plane_count == 1);
+   struct radv_device *device = cmd_buffer->device;
+   unsigned bpp = image->planes[0].surface.bpe;
+   uint64_t dst_address = buffer->bo->va;
+   uint64_t src_address = image->bo->va + image->planes[0].surface.u.gfx9.surf_offset;
+   unsigned src_pitch = image->planes[0].surface.u.gfx9.surf_pitch;
+   unsigned copy_width = DIV_ROUND_UP(image->info.width, image->planes[0].surface.blk_w);
+   unsigned copy_height = DIV_ROUND_UP(image->info.height, image->planes[0].surface.blk_h);
+   bool tmz = false;
+
+   uint32_t ib_pad_dw_mask = cmd_buffer->device->physical_device->rad_info.ib_pad_dw_mask[RING_DMA];
+
+   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 32);
+
+   /* Linear -> linear sub-window copy. */
+   if (image->planes[0].surface.is_linear) {
+      unsigned bytes = src_pitch * copy_height * bpp;
+
+      if (!(bytes < (1u << 22)))
+         return false;
+
+      radeon_emit(cmd_buffer->cs, 0x00000000);
+
+      src_address += image->planes[0].surface.u.gfx9.offset[0];
+
+      radeon_emit(cmd_buffer->cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
+                                  CIK_SDMA_COPY_SUB_OPCODE_LINEAR,
+                                  (tmz ? 4 : 0)));
+      radeon_emit(cmd_buffer->cs, bytes);
+      radeon_emit(cmd_buffer->cs, 0);
+      radeon_emit(cmd_buffer->cs, src_address);
+      radeon_emit(cmd_buffer->cs, src_address >> 32);
+      radeon_emit(cmd_buffer->cs, dst_address);
+      radeon_emit(cmd_buffer->cs, dst_address >> 32);
+
+      while (cmd_buffer->cs->cdw & ib_pad_dw_mask)
+         radeon_emit(cmd_buffer->cs, 0x00000000); /* NOP packet */
+
+      return true;
+   }
+   /* Tiled sub-window copy -> Linear */
+   else {
+      unsigned tiled_width = copy_width;
+      unsigned tiled_height = copy_height;
+      unsigned linear_pitch = region->bufferRowLength;
+      unsigned linear_slice_pitch = region->bufferRowLength * copy_height;
+      uint64_t tiled_address = src_address;
+      uint64_t linear_address = dst_address;
+      bool is_v5 = device->physical_device->rad_info.chip_class >= GFX10;
+      /* Only SDMA 5 supports DCC with SDMA */
+      bool dcc = radv_dcc_enabled(image, 0) && is_v5;
+
+      /* TODO: dcc decompress */
+
+      /* Check if everything fits into the bitfields */
+      if (!(tiled_width < (1 << 14) && tiled_height < (1 << 14) &&
+            linear_pitch < (1 << 14) && linear_slice_pitch < (1 << 28) &&
+            copy_width < (1 << 14) && copy_height < (1 << 14)))
+         return false;
+
+      radeon_emit(cmd_buffer->cs, 0x00000000);
+      radeon_emit(cmd_buffer->cs, 
+         CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
+                         CIK_SDMA_COPY_SUB_OPCODE_TILED_SUB_WINDOW,
+                         (tmz ? 4 : 0)) |
+         dcc << 19 |
+         (is_v5 ? 0 : 0 /* tiled->buffer.b.b.last_level */) << 20 |
+         1u << 31);
+      radeon_emit(cmd_buffer->cs, (uint32_t)tiled_address | (image->planes[0].surface.tile_swizzle << 8));
+      radeon_emit(cmd_buffer->cs, (uint32_t)(tiled_address >> 32));
+      radeon_emit(cmd_buffer->cs, 0);
+      radeon_emit(cmd_buffer->cs, ((tiled_width - 1) << 16));
+      radeon_emit(cmd_buffer->cs, (tiled_height - 1));
+      radeon_emit(cmd_buffer->cs, util_logbase2(bpp) |
+                  image->planes[0].surface.u.gfx9.swizzle_mode << 3 |
+                  image->planes[0].surface.u.gfx9.resource_type << 9 |
+                  (is_v5 ? 0 /* tiled->buffer.b.b.last_level */ : image->planes[0].surface.u.gfx9.epitch) << 16);
+      radeon_emit(cmd_buffer->cs, (uint32_t)linear_address);
+      radeon_emit(cmd_buffer->cs, (uint32_t)(linear_address >> 32));
+      radeon_emit(cmd_buffer->cs, 0);
+      radeon_emit(cmd_buffer->cs, ((linear_pitch - 1) << 16));
+      radeon_emit(cmd_buffer->cs, linear_slice_pitch - 1);
+      radeon_emit(cmd_buffer->cs, (copy_width - 1) | ((copy_height - 1) << 16));
+      radeon_emit(cmd_buffer->cs, 0);
+
+      if (dcc) {
+         unsigned hw_fmt, hw_type;
+         uint64_t md_address = tiled_address + image->planes[0].surface.meta_offset;
+
+         radv_translate_format_to_hw(&device->physical_device->rad_info, image->vk_format, &hw_fmt, &hw_type);
+
+         /* Add metadata */
+         radeon_emit(cmd_buffer->cs, (uint32_t)md_address);
+         radeon_emit(cmd_buffer->cs, (uint32_t)(md_address >> 32));
+         radeon_emit(cmd_buffer->cs, hw_fmt |
+                     vi_alpha_is_on_msb(device, image->vk_format) << 8 |
+                     hw_type << 9 |
+                     image->planes[0].surface.u.gfx9.color.dcc.max_compressed_block_size << 24 |
+                     V_028C78_MAX_BLOCK_SIZE_256B << 26 |
+                     tmz << 29 |
+                     image->planes[0].surface.u.gfx9.color.dcc.pipe_aligned << 31);
+      }
+
+      while (cmd_buffer->cs->cdw & ib_pad_dw_mask)
+         radeon_emit(cmd_buffer->cs, 0x00000000); /* NOP packet */
+
+      return true;
+   }
+
+   return false;
+}
+
+
+bool radv_sdma_copy_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, struct radv_buffer *buffer, const VkBufferImageCopy2KHR *region)
+{
+   assert(cmd_buffer->device->physical_device->rad_info.chip_class >= GFX10);
+   bool r = radv_sdma_v4_v5_copy_image_to_buffer(cmd_buffer, image, buffer, region);
+   assert(r);
+   return true;
+}
-- 
GitLab


From 655b2e975c1892a8be3fe870c2d14a53b0df49b8 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 25 Nov 2021 14:08:28 +0100
Subject: [PATCH 4/5] vk/radv: add a private SDMA pool to exec the DRI_PRIME
 blit

Based on https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12763.

The idea is to make the DRI_PRIME blit completely asynchronous using SDMA.

So instead of creating a command buffer to be executed on present using
the supplied queue, this commit uses an internal SDMA queue to perform
the blit.

The change in radv_QueueSubmit is definitely hacky, but allowed me to test.
Maybe this private_sdma_queue (private_transfer_queue?) should be moved to
vulkan/wsi.

Similarly, when SDMA is used, the original command buffers created in
wsi_create_prime_image become unused (because the SDMA one is always used).
This could probably be cleaned up.
---
 src/amd/vulkan/radv_device.c    | 22 ++++++++++++++++++++++
 src/amd/vulkan/radv_meta_copy.c | 15 +++++++++++++++
 src/amd/vulkan/radv_wsi.c       |  5 +++++
 src/vulkan/wsi/wsi_common.c     | 18 +++++++++++++++---
 src/vulkan/wsi/wsi_common.h     |  2 ++
 src/vulkan/wsi/wsi_common_drm.c |  3 ++-
 src/vulkan/wsi/wsi_common_x11.c | 12 ++++++++++++
 7 files changed, 73 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index a4cb13406e8..2ab5b83011a 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -5002,6 +5002,28 @@ radv_QueueSubmit2KHR(VkQueue _queue, uint32_t submitCount, const VkSubmitInfo2KH
    uint32_t fence_idx = 0;
    bool flushed_caches = false;
 
+   if (submitCount == 1 && pSubmits[0].commandBufferInfoCount == 1) {
+      RADV_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, pSubmits[0].pCommandBufferInfos[0].commandBuffer);
+      if (cmd_buffer->pool->queue_family_index == 2) {
+         struct radv_device *device = queue->device;
+         if (!queue->device->private_sdma_queue) {
+            const VkDeviceQueueCreateInfo queue_create = {
+               .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
+               .queueFamilyIndex = RADV_QUEUE_TRANSFER,
+               .queueCount = 1,
+            };
+            device->private_sdma_queue = vk_alloc(
+                  &device->vk.alloc, sizeof(struct radv_queue), 8,
+                  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE);
+            memset(device->private_sdma_queue, 0, sizeof(struct radv_queue));
+            result = radv_queue_init(device, device->private_sdma_queue, 0,
+                                     &queue_create, NULL);
+            assert(result == VK_SUCCESS);
+         }
+         queue = device->private_sdma_queue;
+      }
+   }
+
    if (radv_device_is_lost(queue->device))
       return VK_ERROR_DEVICE_LOST;
 
diff --git a/src/amd/vulkan/radv_meta_copy.c b/src/amd/vulkan/radv_meta_copy.c
index aed65196c3b..ba467eaceb6 100644
--- a/src/amd/vulkan/radv_meta_copy.c
+++ b/src/amd/vulkan/radv_meta_copy.c
@@ -263,6 +263,21 @@ copy_image_to_buffer(struct radv_cmd_buffer *cmd_buffer, struct radv_buffer *buf
                      struct radv_image *image, VkImageLayout layout,
                      const VkBufferImageCopy2KHR *region)
 {
+   if (cmd_buffer->pool->queue_family_index == RADV_QUEUE_TRANSFER) {
+      /* SDMA copy */
+      assert(!region->imageOffset.x && !region->imageOffset.y && !region->imageOffset.z);
+      assert(image->type == VK_IMAGE_TYPE_2D);
+      assert(image->info.width == region->imageExtent.width);
+      assert(image->info.height == region->imageExtent.height);
+
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
+                         image->bo);
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
+                         buffer->bo);
+      radv_sdma_copy_image(cmd_buffer, image, buffer, region);
+      return;
+   }
+
    struct radv_meta_saved_state saved_state;
    bool old_predicating;
 
diff --git a/src/amd/vulkan/radv_wsi.c b/src/amd/vulkan/radv_wsi.c
index 2b237cdc0f7..a4c2b2cd4d3 100644
--- a/src/amd/vulkan/radv_wsi.c
+++ b/src/amd/vulkan/radv_wsi.c
@@ -25,6 +25,7 @@
 
 #include "util/macros.h"
 #include "util/os_file.h"
+#include "radv_debug.h"
 #include "radv_meta.h"
 #include "radv_private.h"
 #include "vk_util.h"
@@ -100,6 +101,10 @@ radv_init_wsi(struct radv_physical_device *physical_device)
 
    physical_device->vk.wsi_device = &physical_device->wsi_device;
 
+   physical_device->vk.wsi_device->allow_present_sdma =
+      physical_device->rad_info.chip_class >= GFX9 &&
+      !(physical_device->instance->debug_flags & RADV_DEBUG_NO_DMA_BLIT);
+
    return VK_SUCCESS;
 }
 
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 2d18d4c62e1..7f55c5d6a80 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -232,7 +232,7 @@ wsi_swapchain_init(const struct wsi_device *wsi,
    chain->use_prime_blit = false;
 
    chain->cmd_pools =
-      vk_zalloc(pAllocator, sizeof(VkCommandPool) * wsi->queue_family_count, 8,
+      vk_zalloc(pAllocator, sizeof(VkCommandPool) * (wsi->queue_family_count + (wsi->allow_present_sdma ? 1 : 0)), 8,
                 VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    if (!chain->cmd_pools)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -750,8 +750,20 @@ wsi_common_queue_present(const struct wsi_device *wsi,
           * command buffer is attached to the image.
           */
          submit_info.commandBufferCount = 1;
-         submit_info.pCommandBuffers =
-            &image->prime.blit_cmd_buffers[queue_family_index];
+
+         if (wsi->allow_present_sdma) {
+            submit_info.pCommandBuffers =
+               &image->prime.blit_cmd_buffers[wsi->queue_family_count];
+            /* Submit the copy to the SDMA queue */
+            result = wsi->QueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE);
+
+            submit_info.commandBufferCount = 0;
+            submit_info.waitSemaphoreCount = 0;
+            submit_info.pCommandBuffers = NULL;
+         } else {
+            submit_info.pCommandBuffers =
+               &image->prime.blit_cmd_buffers[queue_family_index];
+         }
          mem_signal.memory = image->prime.memory;
       }
 
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 29dfdb779aa..d38d0dbd71d 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -107,6 +107,8 @@ struct wsi_device {
     * available. Not all window systems might support this. */
    bool enable_adaptive_sync;
 
+   bool allow_present_sdma;
+
    /* List of fences to signal when hotplug event happens. */
    struct list_head hotplug_fences;
 
diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index a5e64ecb041..4d401f4296e 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -634,7 +634,8 @@ wsi_create_prime_image(const struct wsi_swapchain *chain,
       goto fail;
    }
 
-   for (uint32_t i = 0; i < wsi->queue_family_count; i++) {
+   /* TODO: or create a single CommandBuffer when allow_present_sdma is enabled? */
+   for (uint32_t i = 0; i < wsi->queue_family_count + wsi->allow_present_sdma ? 1 : 0; i++) {
       const VkCommandBufferAllocateInfo cmd_buffer_info = {
          .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
          .pNext = NULL,
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 9dba416add8..53975e59260 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1803,6 +1803,18 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
       if (!wsi_x11_check_dri3_compatible(wsi_device, conn)) {
          chain->base.use_prime_blit = true;
 
+         /* Add a private SDMA command pool */
+         if (wsi_device->allow_present_sdma) {
+            const VkCommandPoolCreateInfo cmd_pool_info = {
+               .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
+               .pNext = NULL,
+               .flags = 0,
+               .queueFamilyIndex = 2,
+            };
+            result = wsi_device->CreateCommandPool(device, &cmd_pool_info, &chain->base.alloc,
+                                                   &chain->base.cmd_pools[wsi_device->queue_family_count]);
+         }
+
          /* Get display GPU fd through X11 connection */
          xcb_screen_iterator_t screen_iter =
             xcb_setup_roots_iterator(xcb_get_setup(chain->conn));
-- 
GitLab


From 0f0578acd3c9da345321a951f12b0847d7e8aa0f Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 25 Nov 2021 14:08:40 +0100
Subject: [PATCH 5/5] (?) vk,radv: disable implicit sync on the imported linear
 buffer

I'm not sure this commit is really useful: it works identically with
and without it but it kinda makes sense to wait for the blit operation
to finish during acquire image.

(though maybe implicit sync is needed anyway for cross-process sync?)
---
 src/amd/vulkan/radv_device.c        |  2 +-
 src/vulkan/wsi/wsi_common.c         | 40 ++++++++++++++++++++++++++++-
 src/vulkan/wsi/wsi_common_private.h |  1 +
 3 files changed, 41 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 2ab5b83011a..2206fc3ca60 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -5285,7 +5285,7 @@ radv_alloc_memory(struct radv_device *device, const VkMemoryAllocateInfo *pAlloc
 
    radv_device_memory_init(mem, device, NULL);
 
-   if (wsi_info) {
+   if (wsi_info && !import_info) {
       if(wsi_info->implicit_sync)
          flags |= RADEON_FLAG_IMPLICIT_SYNC;
 
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 7f55c5d6a80..3dd538e3218 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -542,6 +542,17 @@ wsi_CreateSwapchainKHR(VkDevice _device,
       return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
 
+   if (wsi_device->allow_present_sdma) {
+      swapchain->sdma_fences = vk_zalloc(alloc,
+                                         sizeof (*swapchain->sdma_fences) * swapchain->image_count,
+                                         sizeof (*swapchain->sdma_fences),
+                                         VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+      if (!swapchain->sdma_fences) {
+         swapchain->destroy(swapchain, alloc);
+         return VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+   }
+
    *pSwapchain = wsi_swapchain_to_handle(swapchain);
 
    return VK_SUCCESS;
@@ -652,6 +663,20 @@ wsi_common_acquire_next_image2(const struct wsi_device *wsi,
                                    image->memory);
    }
 
+   if (swapchain->use_prime_blit && wsi->allow_present_sdma) {
+      if (swapchain->fences[*pImageIndex] != VK_NULL_HANDLE) {
+         result =
+            wsi->WaitForFences(device, 1, &swapchain->sdma_fences[*pImageIndex],
+                               true, ~0ull);
+         if (result != VK_SUCCESS)
+            return result;
+
+         result = wsi->ResetFences(device, 1, &swapchain->sdma_fences[*pImageIndex]);
+         if (result != VK_SUCCESS)
+            return result;
+      }
+   }
+
    return result;
 }
 
@@ -694,6 +719,19 @@ wsi_common_queue_present(const struct wsi_device *wsi,
                                    &swapchain->fences[image_index]);
          if (result != VK_SUCCESS)
             goto fail_present;
+
+         if (swapchain->use_prime_blit && wsi->allow_present_sdma) {
+            const VkFenceCreateInfo fence_info = {
+               .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
+               .pNext = NULL,
+               .flags = 0,
+            };
+            result = wsi->CreateFence(device, &fence_info,
+                                      &swapchain->alloc,
+                                      &swapchain->sdma_fences[image_index]);
+            if (result != VK_SUCCESS)
+               goto fail_present;
+         }
       } else {
          result =
             wsi->WaitForFences(device, 1, &swapchain->fences[image_index],
@@ -755,7 +793,7 @@ wsi_common_queue_present(const struct wsi_device *wsi,
             submit_info.pCommandBuffers =
                &image->prime.blit_cmd_buffers[wsi->queue_family_count];
             /* Submit the copy to the SDMA queue */
-            result = wsi->QueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE);
+            result = wsi->QueueSubmit(queue, 1, &submit_info, swapchain->sdma_fences[image_index]);
 
             submit_info.commandBufferCount = 0;
             submit_info.waitSemaphoreCount = 0;
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 7fe2cd8cca2..38c4bd635f2 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -52,6 +52,7 @@ struct wsi_swapchain {
    VkDevice device;
    VkAllocationCallbacks alloc;
    VkFence* fences;
+   VkFence* sdma_fences;
    VkPresentModeKHR present_mode;
    uint32_t image_count;
 
-- 
GitLab

