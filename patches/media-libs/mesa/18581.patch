From dbfab8a77ff3650c3d54080651148315d263aa20 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Sat, 1 Oct 2022 15:22:41 +0200
Subject: [PATCH 01/12] gallium/tests: drop compute test

The TGSIs don't compile and are rather an annoyence when touching gallium
APIs.

Originally they were written with adding CL support to TGSI, but that
never panned out.

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa@collabora.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/gallium/tests/trivial/compute.c   | 1693 -------------------------
 src/gallium/tests/trivial/meson.build |    2 +-
 2 files changed, 1 insertion(+), 1694 deletions(-)
 delete mode 100644 src/gallium/tests/trivial/compute.c

diff --git a/src/gallium/tests/trivial/compute.c b/src/gallium/tests/trivial/compute.c
deleted file mode 100644
index 1def2182fd8d..000000000000
--- a/src/gallium/tests/trivial/compute.c
+++ /dev/null
@@ -1,1693 +0,0 @@
-/*
- * Copyright (C) 2011 Francisco Jerez.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial
- * portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <sys/stat.h>
-#include <inttypes.h>
-#include "pipe/p_state.h"
-#include "pipe/p_context.h"
-#include "pipe/p_screen.h"
-#include "pipe/p_defines.h"
-#include "pipe/p_shader_tokens.h"
-#include "util/u_memory.h"
-#include "util/u_inlines.h"
-#include "util/u_sampler.h"
-#include "util/format/u_format.h"
-#include "tgsi/tgsi_text.h"
-#include "pipe-loader/pipe_loader.h"
-
-#define MAX_RESOURCES 4
-
-struct context {
-        struct pipe_loader_device *dev;
-        struct pipe_screen *screen;
-        struct pipe_context *pipe;
-        void *hwcs;
-        void *hwsmp[MAX_RESOURCES];
-        struct pipe_resource *tex[MAX_RESOURCES];
-        bool tex_rw[MAX_RESOURCES];
-        struct pipe_sampler_view *view[MAX_RESOURCES];
-        struct pipe_surface *surf[MAX_RESOURCES];
-};
-
-#define DUMP_COMPUTE_PARAM(p, c) do {                                   \
-                uint64_t __v[4];                                        \
-                int __i, __n;                                           \
-                                                                        \
-                __n = ctx->screen->get_compute_param(ctx->screen,       \
-                                                     PIPE_SHADER_IR_TGSI, \
-                                                     c, __v);           \
-                printf("%s: {", #c);                                    \
-                                                                        \
-                for (__i = 0; __i < __n / sizeof(*__v); ++__i)          \
-                        printf(" %"PRIu64, __v[__i]);                   \
-                                                                        \
-                printf(" }\n");                                         \
-        } while (0)
-
-static void init_ctx(struct context *ctx)
-{
-        ASSERTED int ret;
-
-        ret = pipe_loader_probe(&ctx->dev, 1);
-        assert(ret);
-
-        ctx->screen = pipe_loader_create_screen(ctx->dev);
-        assert(ctx->screen);
-
-        ctx->pipe = ctx->screen->context_create(ctx->screen, NULL, 0);
-        assert(ctx->pipe);
-
-        DUMP_COMPUTE_PARAM(p, PIPE_COMPUTE_CAP_GRID_DIMENSION);
-        DUMP_COMPUTE_PARAM(p, PIPE_COMPUTE_CAP_MAX_GRID_SIZE);
-        DUMP_COMPUTE_PARAM(p, PIPE_COMPUTE_CAP_MAX_BLOCK_SIZE);
-}
-
-static void destroy_ctx(struct context *ctx)
-{
-        ctx->pipe->destroy(ctx->pipe);
-        ctx->screen->destroy(ctx->screen);
-        pipe_loader_release(&ctx->dev, 1);
-        FREE(ctx);
-}
-
-static char *
-preprocess_prog(struct context *ctx, const char *src, const char *defs)
-{
-        const char header[] =
-                "#define RGLOBAL        RES[32767]\n"
-                "#define RLOCAL         RES[32766]\n"
-                "#define RPRIVATE       RES[32765]\n"
-                "#define RINPUT         RES[32764]\n";
-        char cmd[512];
-        char tmp[] = "/tmp/test-compute.tgsi-XXXXXX";
-        char *buf;
-        int fd, ret;
-        struct stat st;
-        FILE *p;
-
-        /* Open a temporary file */
-        fd = mkstemp(tmp);
-        assert(fd >= 0);
-        snprintf(cmd, sizeof(cmd), "cpp -P -nostdinc -undef %s > %s",
-                 defs ? defs : "", tmp);
-
-        /* Preprocess */
-        p = popen(cmd, "w");
-        fwrite(header, strlen(header), 1, p);
-        fwrite(src, strlen(src), 1, p);
-        ret = pclose(p);
-        assert(!ret);
-
-        /* Read back */
-        ret = fstat(fd, &st);
-        assert(!ret);
-
-        buf = malloc(st.st_size + 1);
-        ret = read(fd, buf, st.st_size);
-        assert(ret == st.st_size);
-        buf[ret] = 0;
-
-        /* Clean up */
-        close(fd);
-        unlink(tmp);
-
-        return buf;
-}
-
-static void init_prog(struct context *ctx, unsigned local_sz,
-                      unsigned private_sz, unsigned input_sz,
-                      const char *src, const char *defs)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct tgsi_token prog[1024];
-        struct pipe_compute_state cs = {
-                .ir_type = PIPE_SHADER_IR_TGSI,
-                .prog = prog,
-                .req_local_mem = local_sz,
-                .req_private_mem = private_sz,
-                .req_input_mem = input_sz
-        };
-        char *psrc = preprocess_prog(ctx, src, defs);
-        ASSERTED int ret;
-
-        ret = tgsi_text_translate(psrc, prog, ARRAY_SIZE(prog));
-        assert(ret);
-        free(psrc);
-
-        ctx->hwcs = pipe->create_compute_state(pipe, &cs);
-        assert(ctx->hwcs);
-
-        pipe->bind_compute_state(pipe, ctx->hwcs);
-}
-
-static void destroy_prog(struct context *ctx)
-{
-        struct pipe_context *pipe = ctx->pipe;
-
-        pipe->delete_compute_state(pipe, ctx->hwcs);
-        ctx->hwcs = NULL;
-}
-
-static void init_tex(struct context *ctx, int slot,
-                     enum pipe_texture_target target, bool rw,
-                     enum pipe_format format, int w, int h,
-                     void (*init)(void *, int, int, int))
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct pipe_resource **tex = &ctx->tex[slot];
-        struct pipe_resource ttex = {
-                .target = target,
-                .format = format,
-                .width0 = w,
-                .height0 = h,
-                .depth0 = 1,
-                .array_size = 1,
-                .bind = (PIPE_BIND_SAMPLER_VIEW |
-                         PIPE_BIND_COMPUTE_RESOURCE |
-                         PIPE_BIND_GLOBAL)
-        };
-        int dx = util_format_get_blocksize(format);
-        int dy = util_format_get_stride(format, w);
-        int nx = (target == PIPE_BUFFER ? (w / dx) :
-                  util_format_get_nblocksx(format, w));
-        int ny = (target == PIPE_BUFFER ? 1 :
-                  util_format_get_nblocksy(format, h));
-        struct pipe_transfer *xfer;
-        char *map;
-        int x, y;
-
-        *tex = ctx->screen->resource_create(ctx->screen, &ttex);
-        assert(*tex);
-
-        map = pipe->texture_map(pipe, *tex, 0, PIPE_MAP_WRITE,
-                                  &(struct pipe_box) { .width = w,
-                                                  .height = h,
-                                                  .depth = 1 }, &xfer);
-        assert(xfer);
-        assert(map);
-
-        for (y = 0; y < ny; ++y) {
-                for (x = 0; x < nx; ++x) {
-                        init(map + y * dy + x * dx, slot, x, y);
-                }
-        }
-
-        pipe->texture_unmap(pipe, xfer);
-
-        ctx->tex_rw[slot] = rw;
-}
-
-static bool default_check(void *x, void *y, int sz) {
-        return !memcmp(x, y, sz);
-}
-
-static void check_tex(struct context *ctx, int slot,
-                      void (*expect)(void *, int, int, int),
-                      bool (*check)(void *, void *, int))
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct pipe_resource *tex = ctx->tex[slot];
-        int dx = util_format_get_blocksize(tex->format);
-        int dy = util_format_get_stride(tex->format, tex->width0);
-        int nx = (tex->target == PIPE_BUFFER ? (tex->width0 / dx) :
-                  util_format_get_nblocksx(tex->format, tex->width0));
-        int ny = (tex->target == PIPE_BUFFER ? 1 :
-                  util_format_get_nblocksy(tex->format, tex->height0));
-        struct pipe_transfer *xfer;
-        char *map;
-        int x = 0, y, i;
-        int err = 0;
-
-        if (!check)
-                check = default_check;
-
-        map = pipe->texture_map(pipe, tex, 0, PIPE_MAP_READ,
-                                  &(struct pipe_box) { .width = tex->width0,
-                                        .height = tex->height0,
-                                        .depth = 1 }, &xfer);
-        assert(xfer);
-        assert(map);
-
-        for (y = 0; y < ny; ++y) {
-                for (x = 0; x < nx; ++x) {
-                        uint32_t exp[4];
-                        uint32_t *res = (uint32_t *)(map + y * dy + x * dx);
-
-                        expect(exp, slot, x, y);
-                        if (check(res, exp, dx) || (++err) > 20)
-                                continue;
-
-                        if (dx < 4) {
-                                uint32_t u = 0, v = 0;
-
-                                for (i = 0; i < dx; i++) {
-                                        u |= ((uint8_t *)exp)[i] << (8 * i);
-                                        v |= ((uint8_t *)res)[i] << (8 * i);
-                                }
-                                printf("(%d, %d): got 0x%x, expected 0x%x\n",
-                                       x, y, v, u);
-                        } else {
-                                for (i = 0; i < dx / 4; i++) {
-                                        printf("(%d, %d)[%d]: got 0x%x/%f,"
-                                               " expected 0x%x/%f\n", x, y, i,
-                                               res[i], ((float *)res)[i],
-                                               exp[i], ((float *)exp)[i]);
-                                }
-                        }
-                }
-        }
-
-        pipe->texture_unmap(pipe, xfer);
-
-        if (err)
-                printf("(%d, %d): \x1b[31mFAIL\x1b[0m (%d)\n", x, y, err);
-        else
-                printf("(%d, %d): \x1b[32mOK\x1b[0m\n", x, y);
-}
-
-static void destroy_tex(struct context *ctx)
-{
-        int i;
-
-        for (i = 0; i < MAX_RESOURCES; ++i) {
-                if (ctx->tex[i])
-                        pipe_resource_reference(&ctx->tex[i], NULL);
-        }
-}
-
-static void init_sampler_views(struct context *ctx, const int *slots)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct pipe_sampler_view tview;
-        int i;
-
-        for (i = 0; *slots >= 0; ++i, ++slots) {
-                u_sampler_view_default_template(&tview, ctx->tex[*slots],
-                                                ctx->tex[*slots]->format);
-
-                ctx->view[i] = pipe->create_sampler_view(pipe, ctx->tex[*slots],
-                                                         &tview);
-                assert(ctx->view[i]);
-        }
-
-        pipe->set_sampler_views(pipe, PIPE_SHADER_COMPUTE, 0, i, 0, false, ctx->view);
-}
-
-static void destroy_sampler_views(struct context *ctx)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        int i;
-
-        pipe->set_sampler_views(pipe, PIPE_SHADER_COMPUTE, 0, 0, MAX_RESOURCES, false, NULL);
-
-        for (i = 0; i < MAX_RESOURCES; ++i) {
-                if (ctx->view[i]) {
-                        pipe->sampler_view_destroy(pipe, ctx->view[i]);
-                        ctx->view[i] = NULL;
-                }
-        }
-}
-
-static void init_compute_resources(struct context *ctx, const int *slots)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        int i;
-
-        for (i = 0; *slots >= 0; ++i, ++slots) {
-                struct pipe_surface tsurf = {
-                        .format = ctx->tex[*slots]->format,
-                        .writable = ctx->tex_rw[*slots]
-                };
-
-                if (ctx->tex[*slots]->target == PIPE_BUFFER)
-                        tsurf.u.buf.last_element = ctx->tex[*slots]->width0 - 1;
-
-                ctx->surf[i] = pipe->create_surface(pipe, ctx->tex[*slots],
-                                                    &tsurf);
-                assert(ctx->surf[i]);
-        }
-
-        pipe->set_compute_resources(pipe, 0, i, ctx->surf);
-}
-
-static void destroy_compute_resources(struct context *ctx)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        int i;
-
-        pipe->set_compute_resources(pipe, 0, MAX_RESOURCES, NULL);
-
-        for (i = 0; i < MAX_RESOURCES; ++i) {
-                if (ctx->surf[i]) {
-                        pipe->surface_destroy(pipe, ctx->surf[i]);
-                        ctx->surf[i] = NULL;
-                }
-        }
-}
-
-static void init_sampler_states(struct context *ctx, int n)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct pipe_sampler_state smp = {0};
-        int i;
-
-        for (i = 0; i < n; ++i) {
-                ctx->hwsmp[i] = pipe->create_sampler_state(pipe, &smp);
-                assert(ctx->hwsmp[i]);
-        }
-
-        pipe->bind_sampler_states(pipe, PIPE_SHADER_COMPUTE, 0, i, ctx->hwsmp);
-}
-
-static void destroy_sampler_states(struct context *ctx)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        int i;
-
-        pipe->bind_sampler_states(pipe, PIPE_SHADER_COMPUTE,
-				  0, MAX_RESOURCES, NULL);
-
-        for (i = 0; i < MAX_RESOURCES; ++i) {
-                if (ctx->hwsmp[i]) {
-                        pipe->delete_sampler_state(pipe, ctx->hwsmp[i]);
-                        ctx->hwsmp[i] = NULL;
-                }
-        }
-}
-
-static void init_globals(struct context *ctx, const int *slots,
-                         uint32_t **handles)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct pipe_resource *res[MAX_RESOURCES];
-        int i;
-
-        for (i = 0; *slots >= 0; ++i, ++slots)
-                res[i] = ctx->tex[*slots];
-
-        pipe->set_global_binding(pipe, 0, i, res, handles);
-}
-
-static void destroy_globals(struct context *ctx)
-{
-        struct pipe_context *pipe = ctx->pipe;
-
-        pipe->set_global_binding(pipe, 0, MAX_RESOURCES, NULL, NULL);
-}
-
-static void launch_grid(struct context *ctx, const uint *block_layout,
-                        const uint *grid_layout, uint32_t pc,
-                        void *input)
-{
-        struct pipe_context *pipe = ctx->pipe;
-        struct pipe_grid_info info;
-        int i;
-
-        for (i = 0; i < 3; i++) {
-                info.block[i] = block_layout[i];
-                info.grid[i] = grid_layout[i];
-        }
-        info.pc = pc;
-        info.input = input;
-
-        pipe->launch_grid(pipe, &info);
-}
-
-static void test_default_init(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = 0xdeadbeef;
-}
-
-/* test_system_values */
-static void test_system_values_expect(void *p, int s, int x, int y)
-{
-        int id = x / 16, sv = (x % 16) / 4, c = x % 4;
-        int tid[] = { id % 20, (id % 240) / 20, id / 240, 0 };
-        int bsz[] = { 4, 3, 5, 1};
-        int gsz[] = { 5, 4, 1, 1};
-
-        switch (sv) {
-        case 0:
-                *(uint32_t *)p = tid[c] / bsz[c];
-                break;
-        case 1:
-                *(uint32_t *)p = bsz[c];
-                break;
-        case 2:
-                *(uint32_t *)p = gsz[c];
-                break;
-        case 3:
-                *(uint32_t *)p = tid[c] % bsz[c];
-                break;
-        }
-}
-
-static void test_system_values(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL SV[1], BLOCK_SIZE[0]\n"
-                "DCL SV[2], GRID_SIZE[0]\n"
-                "DCL SV[3], THREAD_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 64, 0, 0, 0 }\n"
-                "IMM UINT32 { 16, 0, 0, 0 }\n"
-                "IMM UINT32 { 0, 0, 0, 0 }\n"
-                "\n"
-                "BGNSUB"
-                "  UMUL TEMP[0], SV[0], SV[1]\n"
-                "  UADD TEMP[0], TEMP[0], SV[3]\n"
-                "  UMUL TEMP[1], SV[1], SV[2]\n"
-                "  UMUL TEMP[0].w, TEMP[0], TEMP[1].zzzz\n"
-                "  UMUL TEMP[0].zw, TEMP[0], TEMP[1].yyyy\n"
-                "  UMUL TEMP[0].yzw, TEMP[0], TEMP[1].xxxx\n"
-                "  UADD TEMP[0].xy, TEMP[0].xyxy, TEMP[0].zwzw\n"
-                "  UADD TEMP[0].x, TEMP[0].xxxx, TEMP[0].yyyy\n"
-                "  UMUL TEMP[0].x, TEMP[0], IMM[0]\n"
-                "  STORE RES[0].xyzw, TEMP[0], SV[0]\n"
-                "  UADD TEMP[0].x, TEMP[0], IMM[1]\n"
-                "  STORE RES[0].xyzw, TEMP[0], SV[1]\n"
-                "  UADD TEMP[0].x, TEMP[0], IMM[1]\n"
-                "  STORE RES[0].xyzw, TEMP[0], SV[2]\n"
-                "  UADD TEMP[0].x, TEMP[0], IMM[1]\n"
-                "  STORE RES[0].xyzw, TEMP[0], SV[3]\n"
-                "  RET\n"
-                "ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 76800, 0, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){4, 3, 5}, (uint []){5, 4, 1}, 0, NULL);
-        check_tex(ctx, 0, test_system_values_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_resource_access */
-static void test_resource_access_init0(void *p, int s, int x, int y)
-{
-        *(float *)p = 8.0 - (float)x;
-}
-
-static void test_resource_access_expect(void *p, int s, int x, int y)
-{
-        *(float *)p = 8.0 - (float)((x + 4 * y) & 0x3f);
-}
-
-static void test_resource_access(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL RES[1], 2D, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 15, 0, 0, 0 }\n"
-                "IMM UINT32 { 16, 1, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UADD TEMP[0].x, SV[0].xxxx, SV[0].yyyy\n"
-                "       AND TEMP[0].x, TEMP[0], IMM[0]\n"
-                "       UMUL TEMP[0].x, TEMP[0], IMM[1]\n"
-                "       LOAD TEMP[0].xyzw, RES[0], TEMP[0]\n"
-                "       UMUL TEMP[1], SV[0], IMM[1]\n"
-                "       STORE RES[1].xyzw, TEMP[1], TEMP[0]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_resource_access_init0);
-        init_tex(ctx, 1, PIPE_TEXTURE_2D, true, PIPE_FORMAT_R32_FLOAT,
-                 60, 12, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, 1, -1 });
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){15, 12, 1}, 0, NULL);
-        check_tex(ctx, 1, test_resource_access_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_function_calls */
-static void test_function_calls_init(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = 15 * y + x;
-}
-
-static void test_function_calls_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = (15 * y + x) < 4 ? 2 : 1 ;
-}
-
-static void test_function_calls(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], 2D, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL SV[1], BLOCK_SIZE[0]\n"
-                "DCL SV[2], GRID_SIZE[0]\n"
-                "DCL SV[3], THREAD_ID[0]\n"
-                "DCL TEMP[0]\n"
-                "DCL TEMP[1]\n"
-                "DCL TEMP[2], LOCAL\n"
-                "IMM UINT32 { 0, 11, 22, 33 }\n"
-                "IMM FLT32 { 11, 33, 55, 99 }\n"
-                "IMM UINT32 { 4, 1, 0, 0 }\n"
-                "IMM UINT32 { 12, 0, 0, 0 }\n"
-                "\n"
-                "00: BGNSUB\n"
-                "01:  UMUL TEMP[0].x, TEMP[0], TEMP[0]\n"
-                "02:  UADD TEMP[1].x, TEMP[1], IMM[2].yyyy\n"
-                "03:  USLT TEMP[0].x, TEMP[0], IMM[0]\n"
-                "04:  RET\n"
-                "05: ENDSUB\n"
-                "06: BGNSUB\n"
-                "07:  UMUL TEMP[0].x, TEMP[0], TEMP[0]\n"
-                "08:  UADD TEMP[1].x, TEMP[1], IMM[2].yyyy\n"
-                "09:  USLT TEMP[0].x, TEMP[0], IMM[0].yyyy\n"
-                "10:  IF TEMP[0].xxxx\n"
-                "11:   CAL :0\n"
-                "12:  ENDIF\n"
-                "13:  RET\n"
-                "14: ENDSUB\n"
-                "15: BGNSUB\n"
-                "16:  UMUL TEMP[2], SV[0], SV[1]\n"
-                "17:  UADD TEMP[2], TEMP[2], SV[3]\n"
-                "18:  UMUL TEMP[2], TEMP[2], IMM[2]\n"
-                "00:  MOV TEMP[1].x, IMM[2].wwww\n"
-                "19:  LOAD TEMP[0].x, RES[0].xxxx, TEMP[2]\n"
-                "20:  CAL :6\n"
-                "21:  STORE RES[0].x, TEMP[2], TEMP[1].xxxx\n"
-                "22:  RET\n"
-                "23: ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_TEXTURE_2D, true, PIPE_FORMAT_R32_FLOAT,
-                 15, 12, test_function_calls_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){3, 3, 3}, (uint []){5, 4, 1}, 15, NULL);
-        check_tex(ctx, 0, test_function_calls_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_input_global */
-static void test_input_global_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = 0xdeadbeef - (x == 0 ? 0x10001 + 2 * s : 0);
-}
-
-static void test_input_global(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL SV[0], THREAD_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 8, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0], SV[0], IMM[0]\n"
-                "       LOAD TEMP[1].xy, RINPUT, TEMP[0]\n"
-                "       LOAD TEMP[0].x, RGLOBAL, TEMP[1].yyyy\n"
-                "       UADD TEMP[1].x, TEMP[0], -TEMP[1]\n"
-                "       STORE RGLOBAL.x, TEMP[1].yyyy, TEMP[1]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-        uint32_t input[8] = { 0x10001, 0x10002, 0x10003, 0x10004,
-                              0x10005, 0x10006, 0x10007, 0x10008 };
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 32, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT, 32, 0,
-                 test_default_init);
-        init_tex(ctx, 1, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT, 32, 0,
-                 test_default_init);
-        init_tex(ctx, 2, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT, 32, 0,
-                 test_default_init);
-        init_tex(ctx, 3, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT, 32, 0,
-                 test_default_init);
-        init_globals(ctx, (int []){ 0, 1, 2, 3, -1 },
-                     (uint32_t *[]){ &input[1], &input[3],
-                                     &input[5], &input[7] });
-        launch_grid(ctx, (uint []){4, 1, 1}, (uint []){1, 1, 1}, 0, input);
-        check_tex(ctx, 0, test_input_global_expect, NULL);
-        check_tex(ctx, 1, test_input_global_expect, NULL);
-        check_tex(ctx, 2, test_input_global_expect, NULL);
-        check_tex(ctx, 3, test_input_global_expect, NULL);
-        destroy_globals(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_private */
-static void test_private_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = (x / 32) + x % 32;
-}
-
-static void test_private(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL SV[1], BLOCK_SIZE[0]\n"
-                "DCL SV[2], THREAD_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "DCL TEMP[2], LOCAL\n"
-                "IMM UINT32 { 128, 0, 0, 0 }\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, SV[0], SV[1]\n"
-                "       UADD TEMP[0].x, TEMP[0], SV[2]\n"
-                "       MOV TEMP[1].x, IMM[0].wwww\n"
-                "       BGNLOOP\n"
-                "               USEQ TEMP[2].x, TEMP[1], IMM[0]\n"
-                "               IF TEMP[2]\n"
-                "                       BRK\n"
-                "               ENDIF\n"
-                "               UDIV TEMP[2].x, TEMP[1], IMM[1]\n"
-                "               UADD TEMP[2].x, TEMP[2], TEMP[0]\n"
-                "               STORE RPRIVATE.x, TEMP[1], TEMP[2]\n"
-                "               UADD TEMP[1].x, TEMP[1], IMM[1]\n"
-                "       ENDLOOP\n"
-                "       MOV TEMP[1].x, IMM[0].wwww\n"
-                "       UMUL TEMP[0].x, TEMP[0], IMM[0]\n"
-                "       BGNLOOP\n"
-                "               USEQ TEMP[2].x, TEMP[1], IMM[0]\n"
-                "               IF TEMP[2]\n"
-                "                       BRK\n"
-                "               ENDIF\n"
-                "               LOAD TEMP[2].x, RPRIVATE, TEMP[1]\n"
-                "               STORE RES[0].x, TEMP[0], TEMP[2]\n"
-                "               UADD TEMP[0].x, TEMP[0], IMM[1]\n"
-                "               UADD TEMP[1].x, TEMP[1], IMM[1]\n"
-                "       ENDLOOP\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 128, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 32768, 0, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){16, 1, 1}, (uint []){16, 1, 1}, 0, NULL);
-        check_tex(ctx, 0, test_private_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_local */
-static void test_local_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = x & 0x20 ? 2 : 1;
-}
-
-static void test_local(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL SV[1], BLOCK_SIZE[0]\n"
-                "DCL SV[2], THREAD_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "DCL TEMP[2], LOCAL\n"
-                "IMM UINT32 { 1, 0, 0, 0 }\n"
-                "IMM UINT32 { 2, 0, 0, 0 }\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "IMM UINT32 { 32, 0, 0, 0 }\n"
-                "IMM UINT32 { 128, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, SV[2], IMM[2]\n"
-                "       STORE RLOCAL.x, TEMP[0], IMM[0].wwww\n"
-                "       MFENCE RLOCAL\n"
-                "       USLT TEMP[1].x, SV[2], IMM[3]\n"
-                "       IF TEMP[1]\n"
-                "               UADD TEMP[1].x, TEMP[0], IMM[4]\n"
-                "               BGNLOOP\n"
-                "                       LOAD TEMP[2].x, RLOCAL, TEMP[1]\n"
-                "                       USEQ TEMP[2].x, TEMP[2], IMM[0]\n"
-                "                       IF TEMP[2]\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "               ENDLOOP\n"
-                "               STORE RLOCAL.x, TEMP[0], IMM[0]\n"
-                "               MFENCE RLOCAL\n"
-                "               BGNLOOP\n"
-                "                       LOAD TEMP[2].x, RLOCAL, TEMP[1]\n"
-                "                       USEQ TEMP[2].x, TEMP[2], IMM[1]\n"
-                "                       IF TEMP[2]\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "               ENDLOOP\n"
-                "       ELSE\n"
-                "               UADD TEMP[1].x, TEMP[0], -IMM[4]\n"
-                "               BGNLOOP\n"
-                "                       LOAD TEMP[2].x, RLOCAL, TEMP[1]\n"
-                "                       USEQ TEMP[2].x, TEMP[2], IMM[0].wwww\n"
-                "                       IF TEMP[2]\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "               ENDLOOP\n"
-                "               STORE RLOCAL.x, TEMP[0], IMM[0]\n"
-                "               MFENCE RLOCAL\n"
-                "               BGNLOOP\n"
-                "                       LOAD TEMP[2].x, RLOCAL, TEMP[1]\n"
-                "                       USEQ TEMP[2].x, TEMP[2], IMM[0]\n"
-                "                       IF TEMP[2]\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "               ENDLOOP\n"
-                "               STORE RLOCAL.x, TEMP[0], IMM[1]\n"
-                "               MFENCE RLOCAL\n"
-                "       ENDIF\n"
-                "       UMUL TEMP[1].x, SV[0], SV[1]\n"
-                "       UMUL TEMP[1].x, TEMP[1], IMM[2]\n"
-                "       UADD TEMP[1].x, TEMP[1], TEMP[0]\n"
-                "       LOAD TEMP[0].x, RLOCAL, TEMP[0]\n"
-                "       STORE RES[0].x, TEMP[1], TEMP[0]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 256, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 4096, 0, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){64, 1, 1}, (uint []){16, 1, 1}, 0, NULL);
-        check_tex(ctx, 0, test_local_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_sample */
-static void test_sample_init(void *p, int s, int x, int y)
-{
-        *(float *)p = s ? 1 : x * y;
-}
-
-static void test_sample_expect(void *p, int s, int x, int y)
-{
-        switch (x % 4) {
-        case 0:
-                *(float *)p = x / 4 * y;
-                break;
-        case 1:
-        case 2:
-                *(float *)p = 0;
-                break;
-        case 3:
-                *(float *)p = 1;
-                break;
-        }
-}
-
-static void test_sample(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL SVIEW[0], 2D, FLOAT\n"
-                "DCL RES[0], 2D, RAW, WR\n"
-                "DCL SAMP[0]\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 16, 1, 0, 0 }\n"
-                "IMM FLT32 { 128, 32, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       I2F TEMP[1], SV[0]\n"
-                "       DIV TEMP[1], TEMP[1], IMM[1]\n"
-                "       SAMPLE TEMP[1], TEMP[1], SVIEW[0], SAMP[0]\n"
-                "       UMUL TEMP[0], SV[0], IMM[0]\n"
-                "       STORE RES[0].xyzw, TEMP[0], TEMP[1]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_TEXTURE_2D, true, PIPE_FORMAT_R32_FLOAT,
-                 128, 32, test_sample_init);
-        init_tex(ctx, 1, PIPE_TEXTURE_2D, true, PIPE_FORMAT_R32_FLOAT,
-                 512, 32, test_sample_init);
-        init_compute_resources(ctx, (int []) { 1, -1 });
-        init_sampler_views(ctx, (int []) { 0, -1 });
-        init_sampler_states(ctx, 2);
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){128, 32, 1}, 0, NULL);
-        check_tex(ctx, 1, test_sample_expect, NULL);
-        destroy_sampler_states(ctx);
-        destroy_sampler_views(ctx);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_many_kern */
-static void test_many_kern_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = x;
-}
-
-static void test_many_kern(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL TEMP[0], LOCAL\n"
-                "IMM UINT32 { 0, 1, 2, 3 }\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, IMM[0].xxxx, IMM[1].xxxx\n"
-                "       STORE RES[0].x, TEMP[0], IMM[0].xxxx\n"
-                "       RET\n"
-                "    ENDSUB\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, IMM[0].yyyy, IMM[1].xxxx\n"
-                "       STORE RES[0].x, TEMP[0], IMM[0].yyyy\n"
-                "       RET\n"
-                "    ENDSUB\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, IMM[0].zzzz, IMM[1].xxxx\n"
-                "       STORE RES[0].x, TEMP[0], IMM[0].zzzz\n"
-                "       RET\n"
-                "    ENDSUB\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, IMM[0].wwww, IMM[1].xxxx\n"
-                "       STORE RES[0].x, TEMP[0], IMM[0].wwww\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 16, 0, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){1, 1, 1}, 0, NULL);
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){1, 1, 1}, 5, NULL);
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){1, 1, 1}, 10, NULL);
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){1, 1, 1}, 15, NULL);
-        check_tex(ctx, 0, test_many_kern_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_constant */
-static void test_constant_init(void *p, int s, int x, int y)
-{
-        *(float *)p = s ? 0xdeadbeef : 8.0 - (float)x;
-}
-
-static void test_constant_expect(void *p, int s, int x, int y)
-{
-        *(float *)p = 8.0 - (float)x;
-}
-
-static void test_constant(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW\n"
-                "DCL RES[1], BUFFER, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, SV[0], IMM[0]\n"
-                "       LOAD TEMP[1].x, RES[0], TEMP[0]\n"
-                "       STORE RES[1].x, TEMP[0], TEMP[1]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, false, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_constant_init);
-        init_tex(ctx, 1, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_constant_init);
-        init_compute_resources(ctx, (int []) { 0, 1, -1 });
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){64, 1, 1}, 0, NULL);
-        check_tex(ctx, 1, test_constant_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_resource_indirect */
-static void test_resource_indirect_init(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = s == 0 ? 0xdeadbeef :
-                s == 1 ? x % 2 :
-                s == 2 ? 2 * x :
-                2 * x + 1;
-}
-
-static void test_resource_indirect_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = 2 * x + (x % 2 ? 1 : 0);
-}
-
-static void test_resource_indirect(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL RES[1..3], BUFFER, RAW\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, SV[0], IMM[0]\n"
-                "       LOAD TEMP[1].x, RES[1], TEMP[0]\n"
-                "       LOAD TEMP[1].x, RES[TEMP[1].x+2], TEMP[0]\n"
-                "       STORE RES[0].x, TEMP[0], TEMP[1]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_resource_indirect_init);
-        init_tex(ctx, 1, PIPE_BUFFER, false, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_resource_indirect_init);
-        init_tex(ctx, 2, PIPE_BUFFER, false, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_resource_indirect_init);
-        init_tex(ctx, 3, PIPE_BUFFER, false, PIPE_FORMAT_R32_FLOAT,
-                 256, 0, test_resource_indirect_init);
-        init_compute_resources(ctx, (int []) { 0, 1, 2, 3, -1 });
-        launch_grid(ctx, (uint []){1, 1, 1}, (uint []){64, 1, 1}, 0, NULL);
-        check_tex(ctx, 0, test_resource_indirect_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_surface_ld */
-enum pipe_format surface_fmts[] = {
-        PIPE_FORMAT_B8G8R8A8_UNORM,
-        PIPE_FORMAT_B8G8R8X8_UNORM,
-        PIPE_FORMAT_A8R8G8B8_UNORM,
-        PIPE_FORMAT_X8R8G8B8_UNORM,
-        PIPE_FORMAT_X8R8G8B8_UNORM,
-        PIPE_FORMAT_L8_UNORM,
-        PIPE_FORMAT_A8_UNORM,
-        PIPE_FORMAT_I8_UNORM,
-        PIPE_FORMAT_L8A8_UNORM,
-        PIPE_FORMAT_R32_FLOAT,
-        PIPE_FORMAT_R32G32_FLOAT,
-        PIPE_FORMAT_R32G32B32A32_FLOAT,
-        PIPE_FORMAT_R32_UNORM,
-        PIPE_FORMAT_R32G32_UNORM,
-        PIPE_FORMAT_R32G32B32A32_UNORM,
-        PIPE_FORMAT_R32_SNORM,
-        PIPE_FORMAT_R32G32_SNORM,
-        PIPE_FORMAT_R32G32B32A32_SNORM,
-        PIPE_FORMAT_R8_UINT,
-        PIPE_FORMAT_R8G8_UINT,
-        PIPE_FORMAT_R8G8B8A8_UINT,
-        PIPE_FORMAT_R8_SINT,
-        PIPE_FORMAT_R8G8_SINT,
-        PIPE_FORMAT_R8G8B8A8_SINT,
-        PIPE_FORMAT_R32_UINT,
-        PIPE_FORMAT_R32G32_UINT,
-        PIPE_FORMAT_R32G32B32A32_UINT,
-        PIPE_FORMAT_R32_SINT,
-        PIPE_FORMAT_R32G32_SINT,
-        PIPE_FORMAT_R32G32B32A32_SINT
-};
-
-static void test_surface_ld_init0f(void *p, int s, int x, int y)
-{
-        float v[] = { 1.0, -.75, .50, -.25 };
-        int i = 0;
-
-        util_format_pack_rgba(surface_fmts[i], p, v, 1);
-}
-
-static void test_surface_ld_init0i(void *p, int s, int x, int y)
-{
-        int v[] = { 0xffffffff, 0xffff, 0xff, 0xf };
-        int i = 0;
-
-        util_format_pack_rgba(surface_fmts[i], p, v, 1);
-}
-
-static void test_surface_ld_expectf(void *p, int s, int x, int y)
-{
-        float v[4], w[4];
-        int i = 0;
-
-        test_surface_ld_init0f(v, s, x / 4, y);
-        util_format_unpack_rgba(surface_fmts[i], w, v, 1);
-        *(float *)p = w[x % 4];
-}
-
-static void test_surface_ld_expecti(void *p, int s, int x, int y)
-{
-        int32_t v[4], w[4];
-        int i = 0;
-
-        test_surface_ld_init0i(v, s, x / 4, y);
-        util_format_unpack_rgba(surface_fmts[i], w, v, 1);
-        *(uint32_t *)p = w[x % 4];
-}
-
-static void test_surface_ld(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], 2D\n"
-                "DCL RES[1], 2D, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 16, 1, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       LOAD TEMP[1], RES[0], SV[0]\n"
-                "       UMUL TEMP[0], SV[0], IMM[0]\n"
-                "       STORE RES[1].xyzw, TEMP[0], TEMP[1]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-        int i = 0;
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-
-        for (i = 0; i < ARRAY_SIZE(surface_fmts); i++) {
-                bool is_int = util_format_is_pure_integer(surface_fmts[i]);
-
-                printf("   - %s\n", util_format_name(surface_fmts[i]));
-
-                if (!ctx->screen->is_format_supported(ctx->screen,
-                       surface_fmts[i], PIPE_TEXTURE_2D, 1, 1,
-                       PIPE_BIND_COMPUTE_RESOURCE)) {
-                   printf("(unsupported)\n");
-                   continue;
-                }
-
-                init_tex(ctx, 0, PIPE_TEXTURE_2D, true, surface_fmts[i],
-                         128, 32, (is_int ? test_surface_ld_init0i : test_surface_ld_init0f));
-                init_tex(ctx, 1, PIPE_TEXTURE_2D, true, PIPE_FORMAT_R32_FLOAT,
-                         512, 32, test_default_init);
-                init_compute_resources(ctx, (int []) { 0, 1, -1 });
-                init_sampler_states(ctx, 2);
-                launch_grid(ctx, (uint []){1, 1, 1}, (uint []){128, 32, 1}, 0,
-                            NULL);
-                check_tex(ctx, 1, (is_int ? test_surface_ld_expecti : test_surface_ld_expectf), NULL);
-                destroy_sampler_states(ctx);
-                destroy_compute_resources(ctx);
-                destroy_tex(ctx);
-        }
-
-        destroy_prog(ctx);
-}
-
-/* test_surface_st */
-static void test_surface_st_init0f(void *p, int s, int x, int y)
-{
-        float v[] = { 1.0, -.75, 0.5, -.25 };
-        *(float *)p = v[x % 4];
-}
-
-static void test_surface_st_init0i(void *p, int s, int x, int y)
-{
-        int v[] = { 0xffffffff, 0xffff, 0xff, 0xf };
-        *(int32_t *)p = v[x % 4];
-}
-
-static void test_surface_st_init1(void *p, int s, int x, int y)
-{
-        int i = 0;
-        memset(p, 1, util_format_get_blocksize(surface_fmts[i]));
-}
-
-static void test_surface_st_expectf(void *p, int s, int x, int y)
-{
-        float vf[4];
-        int i = 0, j;
-
-        for (j = 0; j < 4; j++)
-                test_surface_st_init0f(&vf[j], s, 4 * x + j, y);
-        util_format_pack_rgba(surface_fmts[i], p, vf, 1);
-}
-
-static void test_surface_st_expects(void *p, int s, int x, int y)
-{
-        int32_t v[4];
-        int i = 0, j;
-
-        for (j = 0; j < 4; j++)
-                test_surface_st_init0i(&v[j], s, 4 * x + j, y);
-        util_format_pack_rgba(surface_fmts[i], p, v, 1);
-}
-
-static void test_surface_st_expectu(void *p, int s, int x, int y)
-{
-        uint32_t v[4];
-        int i = 0, j;
-
-        for (j = 0; j < 4; j++)
-                test_surface_st_init0i(&v[j], s, 4 * x + j, y);
-        util_format_pack_rgba(surface_fmts[i], p, v, 1);
-}
-
-static unsigned absdiff(uint32_t a, uint32_t b)
-{
-        return (a > b) ? (a - b) : (b - a);
-}
-
-static bool test_surface_st_check(void *x, void *y, int sz)
-{
-        int i = 0, j;
-
-        if (util_format_is_float(surface_fmts[i])) {
-                return fabs(*(float *)x - *(float *)y) < 3.92156863e-3;
-
-        } else if ((sz % 4) == 0) {
-                for (j = 0; j < sz / 4; j++)
-                        if (absdiff(((uint32_t *)x)[j],
-                                    ((uint32_t *)y)[j]) > 1)
-                                return false;
-                return true;
-        } else {
-                return !memcmp(x, y, sz);
-        }
-}
-
-static void test_surface_st(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], 2D, RAW\n"
-                "DCL RES[1], 2D, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "IMM UINT32 { 16, 1, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0], SV[0], IMM[0]\n"
-                "       LOAD TEMP[1], RES[0], TEMP[0]\n"
-                "       STORE RES[1], SV[0], TEMP[1]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-        int i = 0;
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 0, 0, 0, src, NULL);
-
-        for (i = 0; i < ARRAY_SIZE(surface_fmts); i++) {
-                bool is_signed = (util_format_description(surface_fmts[i])
-                                  ->channel[0].type == UTIL_FORMAT_TYPE_SIGNED);
-                bool is_int = util_format_is_pure_integer(surface_fmts[i]);
-
-                printf("   - %s\n", util_format_name(surface_fmts[i]));
-
-                if (!ctx->screen->is_format_supported(ctx->screen,
-                       surface_fmts[i], PIPE_TEXTURE_2D, 1, 1,
-                       PIPE_BIND_COMPUTE_RESOURCE)) {
-                   printf("(unsupported)\n");
-                   continue;
-                }
-
-                init_tex(ctx, 0, PIPE_TEXTURE_2D, true, PIPE_FORMAT_R32_FLOAT,
-                         512, 32, (is_int ? test_surface_st_init0i : test_surface_st_init0f));
-                init_tex(ctx, 1, PIPE_TEXTURE_2D, true, surface_fmts[i],
-                         128, 32, test_surface_st_init1);
-                init_compute_resources(ctx, (int []) { 0, 1, -1 });
-                init_sampler_states(ctx, 2);
-                launch_grid(ctx, (uint []){1, 1, 1}, (uint []){128, 32, 1}, 0,
-                            NULL);
-                check_tex(ctx, 1, (is_int && is_signed ? test_surface_st_expects :
-                                   is_int && !is_signed ? test_surface_st_expectu :
-                                   test_surface_st_expectf), test_surface_st_check);
-                destroy_sampler_states(ctx);
-                destroy_compute_resources(ctx);
-                destroy_tex(ctx);
-        }
-
-        destroy_prog(ctx);
-}
-
-/* test_barrier */
-static void test_barrier_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = 31;
-}
-
-static void test_barrier(struct context *ctx)
-{
-        const char *src = "COMP\n"
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "DCL SV[0], BLOCK_ID[0]\n"
-                "DCL SV[1], BLOCK_SIZE[0]\n"
-                "DCL SV[2], THREAD_ID[0]\n"
-                "DCL TEMP[0], LOCAL\n"
-                "DCL TEMP[1], LOCAL\n"
-                "DCL TEMP[2], LOCAL\n"
-                "DCL TEMP[3], LOCAL\n"
-                "IMM UINT32 { 1, 0, 0, 0 }\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "IMM UINT32 { 32, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL TEMP[0].x, SV[2], IMM[1]\n"
-                "       MOV TEMP[1].x, IMM[0].wwww\n"
-                "       BGNLOOP\n"
-                "               BARRIER\n"
-                "               STORE RLOCAL.x, TEMP[0], TEMP[1]\n"
-                "               BARRIER\n"
-                "               MOV TEMP[2].x, IMM[0].wwww\n"
-                "               BGNLOOP\n"
-                "                       UMUL TEMP[3].x, TEMP[2], IMM[1]\n"
-                "                       LOAD TEMP[3].x, RLOCAL, TEMP[3]\n"
-                "                       USNE TEMP[3].x, TEMP[3], TEMP[1]\n"
-                "                       IF TEMP[3]\n"
-                "                               END\n"
-                "                       ENDIF\n"
-                "                       UADD TEMP[2].x, TEMP[2], IMM[0]\n"
-                "                       USEQ TEMP[3].x, TEMP[2], SV[1]\n"
-                "                       IF TEMP[3]\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "               ENDLOOP\n"
-                "               UADD TEMP[1].x, TEMP[1], IMM[0]\n"
-                "               USEQ TEMP[2].x, TEMP[1], IMM[2]\n"
-                "               IF TEMP[2]\n"
-                "                       BRK\n"
-                "               ENDIF\n"
-                "       ENDLOOP\n"
-                "       UMUL TEMP[1].x, SV[0], SV[1]\n"
-                "       UMUL TEMP[1].x, TEMP[1], IMM[1]\n"
-                "       UADD TEMP[1].x, TEMP[1], TEMP[0]\n"
-                "       LOAD TEMP[0].x, RLOCAL, TEMP[0]\n"
-                "       STORE RES[0].x, TEMP[1], TEMP[0]\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s\n", __func__);
-
-        init_prog(ctx, 256, 0, 0, src, NULL);
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 4096, 0, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){64, 1, 1}, (uint []){16, 1, 1}, 0, NULL);
-        check_tex(ctx, 0, test_barrier_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_atom_ops */
-static void test_atom_ops_init(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = 0xbad;
-}
-
-static void test_atom_ops_expect(void *p, int s, int x, int y)
-{
-        switch (x) {
-        case 0:
-                *(uint32_t *)p = 0xce6c8eef;
-                break;
-        case 1:
-                *(uint32_t *)p = 0xdeadbeef;
-                break;
-        case 2:
-                *(uint32_t *)p = 0x11111111;
-                break;
-        case 3:
-                *(uint32_t *)p = 0x10011001;
-                break;
-        case 4:
-                *(uint32_t *)p = 0xdfbdbfff;
-                break;
-        case 5:
-                *(uint32_t *)p = 0x11111111;
-                break;
-        case 6:
-                *(uint32_t *)p = 0x11111111;
-                break;
-        case 7:
-                *(uint32_t *)p = 0xdeadbeef;
-                break;
-        case 8:
-                *(uint32_t *)p = 0xdeadbeef;
-                break;
-        case 9:
-                *(uint32_t *)p = 0x11111111;
-                break;
-        }
-}
-
-static void test_atom_ops(struct context *ctx, bool global)
-{
-        const char *src = "COMP\n"
-                "#ifdef TARGET_GLOBAL\n"
-                "#define target RES[0]\n"
-                "#else\n"
-                "#define target RLOCAL\n"
-                "#endif\n"
-                ""
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                "#define threadid SV[0]\n"
-                "DCL threadid, THREAD_ID[0]\n"
-                ""
-                "#define offset TEMP[0]\n"
-                "DCL offset, LOCAL\n"
-                "#define tmp TEMP[1]\n"
-                "DCL tmp, LOCAL\n"
-                ""
-                "#define k0 IMM[0]\n"
-                "IMM UINT32 { 0, 0, 0, 0 }\n"
-                "#define k1 IMM[1]\n"
-                "IMM UINT32 { 1, 0, 0, 0 }\n"
-                "#define k2 IMM[2]\n"
-                "IMM UINT32 { 2, 0, 0, 0 }\n"
-                "#define k3 IMM[3]\n"
-                "IMM UINT32 { 3, 0, 0, 0 }\n"
-                "#define k4 IMM[4]\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "#define k5 IMM[5]\n"
-                "IMM UINT32 { 5, 0, 0, 0 }\n"
-                "#define k6 IMM[6]\n"
-                "IMM UINT32 { 6, 0, 0, 0 }\n"
-                "#define k7 IMM[7]\n"
-                "IMM UINT32 { 7, 0, 0, 0 }\n"
-                "#define k8 IMM[8]\n"
-                "IMM UINT32 { 8, 0, 0, 0 }\n"
-                "#define k9 IMM[9]\n"
-                "IMM UINT32 { 9, 0, 0, 0 }\n"
-                "#define korig IMM[10].xxxx\n"
-                "#define karg IMM[10].yyyy\n"
-                "IMM UINT32 { 3735928559, 286331153, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       UMUL offset.x, threadid, k4\n"
-                "       STORE target.x, offset, korig\n"
-                "       USEQ tmp.x, threadid, k0\n"
-                "       IF tmp\n"
-                "               ATOMUADD tmp.x, target, offset, karg\n"
-                "               ATOMUADD tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k1\n"
-                "       IF tmp\n"
-                "               ATOMXCHG tmp.x, target, offset, karg\n"
-                "               ATOMXCHG tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k2\n"
-                "       IF tmp\n"
-                "               ATOMCAS tmp.x, target, offset, korig, karg\n"
-                "               ATOMCAS tmp.x, target, offset, tmp, k0\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k3\n"
-                "       IF tmp\n"
-                "               ATOMAND tmp.x, target, offset, karg\n"
-                "               ATOMAND tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k4\n"
-                "       IF tmp\n"
-                "               ATOMOR tmp.x, target, offset, karg\n"
-                "               ATOMOR tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k5\n"
-                "       IF tmp\n"
-                "               ATOMXOR tmp.x, target, offset, karg\n"
-                "               ATOMXOR tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k6\n"
-                "       IF tmp\n"
-                "               ATOMUMIN tmp.x, target, offset, karg\n"
-                "               ATOMUMIN tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k7\n"
-                "       IF tmp\n"
-                "               ATOMUMAX tmp.x, target, offset, karg\n"
-                "               ATOMUMAX tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k8\n"
-                "       IF tmp\n"
-                "               ATOMIMIN tmp.x, target, offset, karg\n"
-                "               ATOMIMIN tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "       USEQ tmp.x, threadid, k9\n"
-                "       IF tmp\n"
-                "               ATOMIMAX tmp.x, target, offset, karg\n"
-                "               ATOMIMAX tmp.x, target, offset, tmp\n"
-                "       ENDIF\n"
-                "#ifdef TARGET_LOCAL\n"
-                "       LOAD tmp.x, RLOCAL, offset\n"
-                "       STORE RES[0].x, offset, tmp\n"
-                "#endif\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s (%s)\n", __func__, global ? "global" : "local");
-
-        init_prog(ctx, 40, 0, 0, src,
-                  (global ? "-DTARGET_GLOBAL" : "-DTARGET_LOCAL"));
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 40, 0, test_atom_ops_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){10, 1, 1}, (uint []){1, 1, 1}, 0, NULL);
-        check_tex(ctx, 0, test_atom_ops_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-/* test_atom_race */
-static void test_atom_race_expect(void *p, int s, int x, int y)
-{
-        *(uint32_t *)p = x & 0x20 ? 0x11111111 : 0xffffffff;
-}
-
-static void test_atom_race(struct context *ctx, bool global)
-{
-        const char *src = "COMP\n"
-                "#ifdef TARGET_GLOBAL\n"
-                "#define target RES[0]\n"
-                "#else\n"
-                "#define target RLOCAL\n"
-                "#endif\n"
-                ""
-                "DCL RES[0], BUFFER, RAW, WR\n"
-                ""
-                "#define blockid SV[0]\n"
-                "DCL blockid, BLOCK_ID[0]\n"
-                "#define blocksz SV[1]\n"
-                "DCL blocksz, BLOCK_SIZE[0]\n"
-                "#define threadid SV[2]\n"
-                "DCL threadid, THREAD_ID[0]\n"
-                ""
-                "#define offset TEMP[0]\n"
-                "DCL offset, LOCAL\n"
-                "#define arg TEMP[1]\n"
-                "DCL arg, LOCAL\n"
-                "#define count TEMP[2]\n"
-                "DCL count, LOCAL\n"
-                "#define vlocal TEMP[3]\n"
-                "DCL vlocal, LOCAL\n"
-                "#define vshared TEMP[4]\n"
-                "DCL vshared, LOCAL\n"
-                "#define last TEMP[5]\n"
-                "DCL last, LOCAL\n"
-                "#define tmp0 TEMP[6]\n"
-                "DCL tmp0, LOCAL\n"
-                "#define tmp1 TEMP[7]\n"
-                "DCL tmp1, LOCAL\n"
-                ""
-                "#define k0 IMM[0]\n"
-                "IMM UINT32 { 0, 0, 0, 0 }\n"
-                "#define k1 IMM[1]\n"
-                "IMM UINT32 { 1, 0, 0, 0 }\n"
-                "#define k4 IMM[2]\n"
-                "IMM UINT32 { 4, 0, 0, 0 }\n"
-                "#define k32 IMM[3]\n"
-                "IMM UINT32 { 32, 0, 0, 0 }\n"
-                "#define k128 IMM[4]\n"
-                "IMM UINT32 { 128, 0, 0, 0 }\n"
-                "#define kdeadcafe IMM[5]\n"
-                "IMM UINT32 { 3735931646, 0, 0, 0 }\n"
-                "#define kallowed_set IMM[6]\n"
-                "IMM UINT32 { 559035650, 0, 0, 0 }\n"
-                "#define k11111111 IMM[7]\n"
-                "IMM UINT32 { 286331153, 0, 0, 0 }\n"
-                "\n"
-                "    BGNSUB\n"
-                "       MOV offset.x, threadid\n"
-                "#ifdef TARGET_GLOBAL\n"
-                "       UMUL tmp0.x, blockid, blocksz\n"
-                "       UADD offset.x, offset, tmp0\n"
-                "#endif\n"
-                "       UMUL offset.x, offset, k4\n"
-                "       USLT tmp0.x, threadid, k32\n"
-                "       STORE target.x, offset, k0\n"
-                "       BARRIER\n"
-                "       IF tmp0\n"
-                "               MOV vlocal.x, k0\n"
-                "               MOV arg.x, kdeadcafe\n"
-                "               BGNLOOP\n"
-                "                       INEG arg.x, arg\n"
-                "                       ATOMUADD vshared.x, target, offset, arg\n"
-                "                       SFENCE target\n"
-                "                       USNE tmp0.x, vshared, vlocal\n"
-                "                       IF tmp0\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "                       UADD vlocal.x, vlocal, arg\n"
-                "               ENDLOOP\n"
-                "               UADD vlocal.x, vshared, arg\n"
-                "               LOAD vshared.x, target, offset\n"
-                "               USEQ tmp0.x, vshared, vlocal\n"
-                "               STORE target.x, offset, tmp0\n"
-                "       ELSE\n"
-                "               UADD offset.x, offset, -k128\n"
-                "               MOV count.x, k0\n"
-                "               MOV last.x, k0\n"
-                "               BGNLOOP\n"
-                "                       LOAD vshared.x, target, offset\n"
-                "                       USEQ tmp0.x, vshared, kallowed_set.xxxx\n"
-                "                       USEQ tmp1.x, vshared, kallowed_set.yyyy\n"
-                "                       OR tmp0.x, tmp0, tmp1\n"
-                "                       IF tmp0\n"
-                "                               USEQ tmp0.x, vshared, last\n"
-                "                               IF tmp0\n"
-                "                                       CONT\n"
-                "                               ENDIF\n"
-                "                               MOV last.x, vshared\n"
-                "                       ELSE\n"
-                "                               END\n"
-                "                       ENDIF\n"
-                "                       UADD count.x, count, k1\n"
-                "                       USEQ tmp0.x, count, k128\n"
-                "                       IF tmp0\n"
-                "                               BRK\n"
-                "                       ENDIF\n"
-                "               ENDLOOP\n"
-                "               ATOMXCHG tmp0.x, target, offset, k11111111\n"
-                "               UADD offset.x, offset, k128\n"
-                "               ATOMXCHG tmp0.x, target, offset, k11111111\n"
-                "               SFENCE target\n"
-                "       ENDIF\n"
-                "#ifdef TARGET_LOCAL\n"
-                "       LOAD tmp0.x, RLOCAL, offset\n"
-                "       UMUL tmp1.x, blockid, blocksz\n"
-                "       UMUL tmp1.x, tmp1, k4\n"
-                "       UADD offset.x, offset, tmp1\n"
-                "       STORE RES[0].x, offset, tmp0\n"
-                "#endif\n"
-                "       RET\n"
-                "    ENDSUB\n";
-
-        printf("- %s (%s)\n", __func__, global ? "global" : "local");
-
-        init_prog(ctx, 256, 0, 0, src,
-                  (global ? "-DTARGET_GLOBAL" : "-DTARGET_LOCAL"));
-        init_tex(ctx, 0, PIPE_BUFFER, true, PIPE_FORMAT_R32_FLOAT,
-                 4096, 0, test_default_init);
-        init_compute_resources(ctx, (int []) { 0, -1 });
-        launch_grid(ctx, (uint []){64, 1, 1}, (uint []){16, 1, 1}, 0, NULL);
-        check_tex(ctx, 0, test_atom_race_expect, NULL);
-        destroy_compute_resources(ctx);
-        destroy_tex(ctx);
-        destroy_prog(ctx);
-}
-
-int main(int argc, char *argv[])
-{
-        struct context *ctx = CALLOC_STRUCT(context);
-
-        unsigned tests = (argc > 1) ? strtoul(argv[1], NULL, 0) : ~0;
-
-        init_ctx(ctx);
-
-        if (tests & (1 << 0))
-           test_system_values(ctx);
-        if (tests & (1 << 1))
-           test_resource_access(ctx);
-        if (tests & (1 << 2))
-           test_function_calls(ctx);
-        if (tests & (1 << 3))
-           test_input_global(ctx);
-        if (tests & (1 << 4))
-           test_private(ctx);
-        if (tests & (1 << 5))
-           test_local(ctx);
-        if (tests & (1 << 6))
-           test_sample(ctx);
-        if (tests & (1 << 7))
-           test_many_kern(ctx);
-        if (tests & (1 << 8))
-           test_constant(ctx);
-        if (tests & (1 << 9))
-           test_resource_indirect(ctx);
-        if (tests & (1 << 10))
-           test_surface_ld(ctx);
-        if (tests & (1 << 11))
-           test_surface_st(ctx);
-        if (tests & (1 << 12))
-           test_barrier(ctx);
-        if (tests & (1 << 13))
-           test_atom_ops(ctx, true);
-        if (tests & (1 << 14))
-           test_atom_race(ctx, true);
-        if (tests & (1 << 15))
-           test_atom_ops(ctx, false);
-        if (tests & (1 << 16))
-           test_atom_race(ctx, false);
-
-        destroy_ctx(ctx);
-
-        return 0;
-}
diff --git a/src/gallium/tests/trivial/meson.build b/src/gallium/tests/trivial/meson.build
index a54e71d72250..a2286afe0960 100644
--- a/src/gallium/tests/trivial/meson.build
+++ b/src/gallium/tests/trivial/meson.build
@@ -18,7 +18,7 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 # SOFTWARE.
 
-foreach t : ['compute', 'tri', 'quad-tex']
+foreach t : ['tri', 'quad-tex']
   executable(
     t,
     '@0@.c'.format(t),
-- 
GitLab


From d2a73f46b8a08613f4b037c74c5fee5c1e66c91d Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Tue, 13 Sep 2022 18:58:07 +0200
Subject: [PATCH 02/12] gallium: drop pipe_compute_state.req_private_mem
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

nothing used it and nothing will use it, so just drop it and clean up some
dead struct fields in drivers.

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
Reviewed-by: Marek Olk <marek.olsak@amd.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/gallium/auxiliary/driver_trace/tr_dump_state.c   |  1 -
 src/gallium/drivers/nouveau/nv50/nv50_program.h      |  1 -
 src/gallium/drivers/nouveau/nv50/nv50_state.c        |  1 -
 src/gallium/drivers/nouveau/nvc0/nvc0_compute.c      |  2 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_program.h      |  1 -
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c        |  1 -
 src/gallium/drivers/nouveau/nvc0/nve4_compute.c      | 12 +++---------
 src/gallium/drivers/r600/evergreen_compute.c         |  1 -
 .../drivers/r600/evergreen_compute_internal.h        |  1 -
 src/gallium/drivers/radeonsi/si_compute.c            |  3 ---
 src/gallium/drivers/radeonsi/si_compute.h            |  1 -
 src/gallium/frontends/rusticl/mesa/pipe/context.rs   |  1 -
 src/gallium/include/pipe/p_state.h                   |  1 -
 13 files changed, 4 insertions(+), 23 deletions(-)

diff --git a/src/gallium/auxiliary/driver_trace/tr_dump_state.c b/src/gallium/auxiliary/driver_trace/tr_dump_state.c
index 036e43c0ad81..410ac5a1abc8 100644
--- a/src/gallium/auxiliary/driver_trace/tr_dump_state.c
+++ b/src/gallium/auxiliary/driver_trace/tr_dump_state.c
@@ -350,7 +350,6 @@ void trace_dump_compute_state(const struct pipe_compute_state *state)
    trace_dump_member_end();
 
    trace_dump_member(uint, state, req_local_mem);
-   trace_dump_member(uint, state, req_private_mem);
    trace_dump_member(uint, state, req_input_mem);
 
    trace_dump_struct_end();
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_program.h b/src/gallium/drivers/nouveau/nv50/nv50_program.h
index d89cd9d13d2d..f2b945cd0b18 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_program.h
+++ b/src/gallium/drivers/nouveau/nv50/nv50_program.h
@@ -107,7 +107,6 @@ struct nv50_program {
    } gp;
 
    struct {
-      uint32_t lmem_size; /* local memory (TGSI PRIVATE resource) size */
       uint32_t smem_size; /* shared memory (TGSI LOCAL resource) size */
       struct nv50_gmem_state gmem[NV50_MAX_GLOBALS];
    } cp;
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 217584082535..0cdf2afacc9c 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -862,7 +862,6 @@ nv50_cp_state_create(struct pipe_context *pipe,
    }
 
    prog->cp.smem_size = cso->req_local_mem;
-   prog->cp.lmem_size = cso->req_private_mem;
    prog->parm_size = cso->req_input_mem;
 
    return (void *)prog;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c b/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
index b2b00f4ba984..e9f0cbe77683 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
@@ -441,7 +441,7 @@ nvc0_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
    PUSH_DATA (push, cp->code_base);
 
    BEGIN_NVC0(push, NVC0_CP(LOCAL_POS_ALLOC), 3);
-   PUSH_DATA (push, (cp->hdr[1] & 0xfffff0) + align(cp->cp.lmem_size, 0x10));
+   PUSH_DATA (push, cp->hdr[1] & 0xfffff0);
    PUSH_DATA (push, 0);
    PUSH_DATA (push, 0x800); /* WARP_CSTACK_SIZE */
 
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_program.h b/src/gallium/drivers/nouveau/nvc0/nvc0_program.h
index 74996fbc867a..536841f60f77 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_program.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_program.h
@@ -60,7 +60,6 @@ struct nvc0_program {
       uint32_t tess_mode; /* ~0 if defined by the other stage */
    } tp;
    struct {
-      uint32_t lmem_size; /* local memory (TGSI PRIVATE resource) size */
       uint32_t smem_size; /* shared memory (TGSI LOCAL resource) size */
    } cp;
    uint8_t num_barriers;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index 2f4a9c117d29..4d4b5c431ea2 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -742,7 +742,6 @@ nvc0_cp_state_create(struct pipe_context *pipe,
    prog->pipe.type = cso->ir_type;
 
    prog->cp.smem_size = cso->req_local_mem;
-   prog->cp.lmem_size = cso->req_private_mem;
    prog->parm_size = cso->req_input_mem;
 
    switch(cso->ir_type) {
diff --git a/src/gallium/drivers/nouveau/nvc0/nve4_compute.c b/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
index 23d157fd4bf0..8758efd59c43 100644
--- a/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
+++ b/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
@@ -649,9 +649,7 @@ nve4_compute_setup_launch_desc(struct nvc0_context *nvc0, uint32_t *qmd,
 
    NVA0C0_QMDV00_06_VAL_SET(qmd, SHARED_MEMORY_SIZE,
                                  align(cp->cp.smem_size, 0x100));
-   NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE,
-                                 (cp->hdr[1] & 0xfffff0) +
-                                 align(cp->cp.lmem_size, 0x10));
+   NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE, cp->hdr[1] & 0xfffff0);
    NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_HIGH_SIZE, 0);
    NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_CRS_SIZE, 0x800);
 
@@ -709,9 +707,7 @@ gp100_compute_setup_launch_desc(struct nvc0_context *nvc0, uint32_t *qmd,
 
    NVC0C0_QMDV02_01_VAL_SET(qmd, SHARED_MEMORY_SIZE,
                                  align(cp->cp.smem_size, 0x100));
-   NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE,
-                                 (cp->hdr[1] & 0xfffff0) +
-                                 align(cp->cp.lmem_size, 0x10));
+   NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE, cp->hdr[1] & 0xfffff0);
    NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_HIGH_SIZE, 0);
    NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_CRS_SIZE, 0x800);
 
@@ -759,9 +755,7 @@ gv100_compute_setup_launch_desc(struct nvc0_context *nvc0, u32 *qmd,
    NVC3C0_QMDV02_02_DEF_SET(qmd, SAMPLER_INDEX, INDEPENDENTLY);
    NVC3C0_QMDV02_02_VAL_SET(qmd, SHARED_MEMORY_SIZE,
                                   align(cp->cp.smem_size, 0x100));
-   NVC3C0_QMDV02_02_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE,
-                                 (cp->hdr[1] & 0xfffff0) +
-                                 align(cp->cp.lmem_size, 0x10));
+   NVC3C0_QMDV02_02_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE, cp->hdr[1] & 0xfffff0);
    NVC3C0_QMDV02_02_VAL_SET(qmd, SHADER_LOCAL_MEMORY_HIGH_SIZE, 0);
    NVC3C0_QMDV02_02_VAL_SET(qmd, MIN_SM_CONFIG_SHARED_MEM_SIZE,
                                   gv100_sm_config_smem_size(8 * 1024));
diff --git a/src/gallium/drivers/r600/evergreen_compute.c b/src/gallium/drivers/r600/evergreen_compute.c
index d1fe115bbd2a..baef801d0ec6 100644
--- a/src/gallium/drivers/r600/evergreen_compute.c
+++ b/src/gallium/drivers/r600/evergreen_compute.c
@@ -436,7 +436,6 @@ static void *evergreen_create_compute_state(struct pipe_context *ctx,
 
 	shader->ctx = rctx;
 	shader->local_size = cso->req_local_mem;
-	shader->private_size = cso->req_private_mem;
 	shader->input_size = cso->req_input_mem;
 
 	shader->ir_type = cso->ir_type;
diff --git a/src/gallium/drivers/r600/evergreen_compute_internal.h b/src/gallium/drivers/r600/evergreen_compute_internal.h
index 4f3ba564fd07..b2722fe7999e 100644
--- a/src/gallium/drivers/r600/evergreen_compute_internal.h
+++ b/src/gallium/drivers/r600/evergreen_compute_internal.h
@@ -81,7 +81,6 @@ struct r600_pipe_compute {
 	struct r600_bytecode bc;
 
 	unsigned local_size;
-	unsigned private_size;
 	unsigned input_size;
 	struct r600_resource *kernel_param;
 
diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index 3e09dda62bf9..6bc9db5ce851 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -49,7 +49,6 @@ struct dispatch_packet {
    uint32_t grid_size_x;
    uint32_t grid_size_y;
    uint32_t grid_size_z;
-   uint32_t private_segment_size;
    uint32_t group_segment_size;
    uint64_t kernel_object;
    uint64_t kernarg_address;
@@ -245,7 +244,6 @@ static void *si_create_compute_state(struct pipe_context *ctx, const struct pipe
    program->shader.selector = &program->sel;
    program->shader.wave_size = si_determine_wave_size(sscreen, &program->shader);
    program->ir_type = cso->ir_type;
-   program->private_size = cso->req_private_mem;
    program->input_size = cso->req_input_mem;
 
    if (cso->ir_type != PIPE_SHADER_IR_NATIVE) {
@@ -677,7 +675,6 @@ static void si_setup_user_sgprs_co_v2(struct si_context *sctx, const amd_kernel_
       dispatch.grid_size_y = util_cpu_to_le32(info->grid[1] * info->block[1]);
       dispatch.grid_size_z = util_cpu_to_le32(info->grid[2] * info->block[2]);
 
-      dispatch.private_segment_size = util_cpu_to_le32(program->private_size);
       dispatch.group_segment_size = util_cpu_to_le32(program->sel.info.base.shared_size);
 
       dispatch.kernarg_address = util_cpu_to_le64(kernel_args_va);
diff --git a/src/gallium/drivers/radeonsi/si_compute.h b/src/gallium/drivers/radeonsi/si_compute.h
index 305059a6cb6f..b5624f201951 100644
--- a/src/gallium/drivers/radeonsi/si_compute.h
+++ b/src/gallium/drivers/radeonsi/si_compute.h
@@ -33,7 +33,6 @@ struct si_compute {
    struct si_shader shader;
 
    unsigned ir_type;
-   unsigned private_size;
    unsigned input_size;
 
    int max_global_buffers;
diff --git a/src/gallium/frontends/rusticl/mesa/pipe/context.rs b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
index 234874fcf0c2..39a18be20a48 100644
--- a/src/gallium/frontends/rusticl/mesa/pipe/context.rs
+++ b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
@@ -276,7 +276,6 @@ impl PipeContext {
             prog: nir.dup_for_driver().cast(),
             req_input_mem: input_mem,
             req_local_mem: local_mem,
-            req_private_mem: 0,
         };
         unsafe { self.pipe.as_ref().create_compute_state.unwrap()(self.pipe.as_ptr(), &state) }
     }
diff --git a/src/gallium/include/pipe/p_state.h b/src/gallium/include/pipe/p_state.h
index 0155eecb3f9b..34154cef08e7 100644
--- a/src/gallium/include/pipe/p_state.h
+++ b/src/gallium/include/pipe/p_state.h
@@ -1006,7 +1006,6 @@ struct pipe_compute_state
    enum pipe_shader_ir ir_type; /**< IR type contained in prog. */
    const void *prog; /**< Compute program to be executed. */
    unsigned req_local_mem; /**< Required size of the LOCAL resource. */
-   unsigned req_private_mem; /**< Required size of the PRIVATE resource. */
    unsigned req_input_mem; /**< Required size of the INPUT resource. */
 };
 
-- 
GitLab


From e490093744b88e70d22f816bdf896ed544f7f70b Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Thu, 20 Oct 2022 02:54:39 +0200
Subject: [PATCH 03/12] nir: set range and base for load_kernel_input

---
 src/compiler/nir/nir_lower_io.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index 1776648c456d..0125d411444e 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -1498,6 +1498,10 @@ build_explicit_io_load(nir_builder *b, nir_intrinsic_instr *intrin,
    if (op == nir_intrinsic_load_constant) {
       nir_intrinsic_set_base(load, 0);
       nir_intrinsic_set_range(load, b->shader->constant_data_size);
+   } else if (op == nir_intrinsic_load_kernel_input) {
+      nir_variable *var = nir_deref_instr_get_variable(deref);
+      nir_intrinsic_set_base(load, 0);
+      nir_intrinsic_set_range(load, glsl_get_explicit_size(var->type, false));
    } else if (mode == nir_var_mem_push_const) {
       /* Push constants are required to be able to be chased back to the
        * variable so we can provide a base/range.
-- 
GitLab


From 403bc1ce388e726d22a0f322fbfe28a12ef54e13 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Thu, 20 Oct 2022 02:54:55 +0200
Subject: [PATCH 04/12] rusticl/nir: add load_kernel_input lowering pass

---
 src/gallium/frontends/rusticl/rusticl_nir.c | 70 +++++++++++++++++++++
 src/gallium/frontends/rusticl/rusticl_nir.h |  1 +
 2 files changed, 71 insertions(+)

diff --git a/src/gallium/frontends/rusticl/rusticl_nir.c b/src/gallium/frontends/rusticl/rusticl_nir.c
index 542f735612cc..74e3ee83a57d 100644
--- a/src/gallium/frontends/rusticl/rusticl_nir.c
+++ b/src/gallium/frontends/rusticl/rusticl_nir.c
@@ -74,3 +74,73 @@ rusticl_lower_intrinsics(nir_shader *nir, struct rusticl_lower_state* state)
         state
     );
 }
+
+static nir_ssa_def*
+rusticl_lower_input_instr(struct nir_builder *b, nir_instr *instr, void *_)
+{
+   nir_intrinsic_instr *intrins = nir_instr_as_intrinsic(instr);
+   if (intrins->intrinsic != nir_intrinsic_load_kernel_input)
+      return NULL;
+
+   nir_ssa_def *ubo_idx = nir_imm_int(b, 0);
+   nir_ssa_def *uniform_offset = nir_ssa_for_src(b, intrins->src[0], 1);
+
+   assert(intrins->dest.ssa.bit_size >= 8);
+   nir_ssa_def *load_result =
+      nir_load_ubo(b, intrins->num_components, intrins->dest.ssa.bit_size,
+                   ubo_idx, nir_iadd_imm(b, uniform_offset, nir_intrinsic_base(intrins)));
+
+   nir_intrinsic_instr *load = nir_instr_as_intrinsic(load_result->parent_instr);
+
+   /* If it's const, set the alignment to our known constant offset.  If
+    * not, set it to a pessimistic value based on the multiplier (or the
+    * scalar size, for qword loads).
+    *
+    * We could potentially set up stricter alignments for indirects by
+    * knowing what features are enabled in the APIs (see comment in
+    * nir_lower_ubo_vec4.c)
+    */
+   if (nir_src_is_const(intrins->src[0])) {
+      nir_intrinsic_set_align(load, NIR_ALIGN_MUL_MAX,
+                              (nir_src_as_uint(intrins->src[0]) +
+                              nir_intrinsic_base(intrins) * 1) %
+                              NIR_ALIGN_MUL_MAX);
+   } else {
+      nir_intrinsic_set_align(load, intrins->dest.ssa.bit_size / 8, 0);
+   }
+
+   nir_intrinsic_set_range_base(load, nir_intrinsic_base(intrins));
+   nir_intrinsic_set_range(load, nir_intrinsic_range(intrins));
+   return load_result;
+}
+
+bool
+rusticl_lower_inputs(nir_shader *shader)
+{
+   bool progress = false;
+
+   assert(!shader->info.first_ubo_is_default_ubo);
+
+   progress = nir_shader_lower_instructions(
+      shader,
+      rusticl_lower_intrinsics_filter,
+      rusticl_lower_input_instr,
+      NULL
+   );
+
+   nir_foreach_variable_with_modes(var, shader, nir_var_mem_ubo) {
+      var->data.binding++;
+      var->data.driver_location++;
+   }
+   shader->info.num_ubos++;
+
+   if (shader->num_uniforms > 0) {
+      const struct glsl_type *type = glsl_array_type(glsl_uint8_t_type(), shader->num_uniforms, 1);
+      nir_variable *ubo = nir_variable_create(shader, nir_var_mem_ubo, type, "kernel_input");
+      ubo->data.binding = 0;
+      ubo->data.explicit_binding = 1;
+   }
+
+   shader->info.first_ubo_is_default_ubo = true;
+   return progress;
+}
diff --git a/src/gallium/frontends/rusticl/rusticl_nir.h b/src/gallium/frontends/rusticl/rusticl_nir.h
index fefd0b3bcf70..032ac8fdb668 100644
--- a/src/gallium/frontends/rusticl/rusticl_nir.h
+++ b/src/gallium/frontends/rusticl/rusticl_nir.h
@@ -7,3 +7,4 @@ struct rusticl_lower_state {
 };
 
 bool rusticl_lower_intrinsics(nir_shader *nir, struct rusticl_lower_state *state);
+bool rusticl_lower_inputs(nir_shader *nir);
-- 
GitLab


From d78e08a1394aef9538245fc74218544d07b1426b Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Wed, 14 Sep 2022 17:53:18 +0200
Subject: [PATCH 05/12] rusticl: use real constant buffer for cb0

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/gallium/frontends/rusticl/core/kernel.rs  |  9 ++++--
 .../frontends/rusticl/mesa/pipe/context.rs    | 32 +++++++++++++------
 2 files changed, 30 insertions(+), 11 deletions(-)

diff --git a/src/gallium/frontends/rusticl/core/kernel.rs b/src/gallium/frontends/rusticl/core/kernel.rs
index 927b1592e1d1..5b2cf74d8716 100644
--- a/src/gallium/frontends/rusticl/core/kernel.rs
+++ b/src/gallium/frontends/rusticl/core/kernel.rs
@@ -557,6 +557,10 @@ fn lower_and_optimize_nir_late(
         nir.pass0(nir_lower_int64);
     }
 
+    if nir_options.lower_uniforms_to_ubo {
+        nir.pass0(rusticl_lower_inputs);
+    }
+
     nir.pass1(nir_lower_convert_alu_types, None);
 
     opt_nir(nir, dev);
@@ -933,15 +937,16 @@ impl Kernel {
                     init_data.len() as u32,
                 );
             }
-            let cso = ctx.create_compute_state(nir, input.len() as u32, local_size as u32);
+            let cso = ctx.create_compute_state(nir, local_size as u32);
 
             ctx.bind_compute_state(cso);
             ctx.bind_sampler_states(&samplers);
             ctx.set_sampler_views(&mut sviews);
             ctx.set_shader_images(&iviews);
             ctx.set_global_binding(resources.as_slice(), &mut globals);
+            ctx.set_constant_buffer(0, &input);
 
-            ctx.launch_grid(work_dim, block, grid, &input);
+            ctx.launch_grid(work_dim, block, grid);
 
             ctx.clear_global_binding(globals.len() as u32);
             ctx.clear_shader_images(iviews.len() as u32);
diff --git a/src/gallium/frontends/rusticl/mesa/pipe/context.rs b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
index 39a18be20a48..bda36c41e8c4 100644
--- a/src/gallium/frontends/rusticl/mesa/pipe/context.rs
+++ b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
@@ -265,16 +265,11 @@ impl PipeContext {
         unsafe { self.pipe.as_ref().texture_unmap.unwrap()(self.pipe.as_ptr(), tx) };
     }
 
-    pub fn create_compute_state(
-        &self,
-        nir: &NirShader,
-        input_mem: u32,
-        local_mem: u32,
-    ) -> *mut c_void {
+    pub fn create_compute_state(&self, nir: &NirShader, local_mem: u32) -> *mut c_void {
         let state = pipe_compute_state {
             ir_type: pipe_shader_ir::PIPE_SHADER_IR_NIR,
             prog: nir.dup_for_driver().cast(),
-            req_input_mem: input_mem,
+            req_input_mem: 0,
             req_local_mem: local_mem,
         };
         unsafe { self.pipe.as_ref().create_compute_state.unwrap()(self.pipe.as_ptr(), &state) }
@@ -321,10 +316,28 @@ impl PipeContext {
         unsafe { self.pipe.as_ref().delete_sampler_state.unwrap()(self.pipe.as_ptr(), ptr) }
     }
 
-    pub fn launch_grid(&self, work_dim: u32, block: [u32; 3], grid: [u32; 3], input: &[u8]) {
+    pub fn set_constant_buffer(&self, idx: u32, data: &[u8]) {
+        let cb = pipe_constant_buffer {
+            buffer: ptr::null_mut(),
+            buffer_offset: 0,
+            buffer_size: data.len() as u32,
+            user_buffer: data.as_ptr().cast(),
+        };
+        unsafe {
+            self.pipe.as_ref().set_constant_buffer.unwrap()(
+                self.pipe.as_ptr(),
+                pipe_shader_type::PIPE_SHADER_COMPUTE,
+                idx,
+                false,
+                &cb,
+            )
+        }
+    }
+
+    pub fn launch_grid(&self, work_dim: u32, block: [u32; 3], grid: [u32; 3]) {
         let info = pipe_grid_info {
             pc: 0,
-            input: input.as_ptr().cast(),
+            input: ptr::null(),
             work_dim: work_dim,
             block: block,
             last_block: [0; 3],
@@ -475,6 +488,7 @@ fn has_required_cbs(c: &pipe_context) -> bool {
         && c.memory_barrier.is_some()
         && c.resource_copy_region.is_some()
         && c.sampler_view_destroy.is_some()
+        && c.set_constant_buffer.is_some()
         && c.set_global_binding.is_some()
         && c.set_sampler_views.is_some()
         && c.set_shader_images.is_some()
-- 
GitLab


From 36caa9e62215dd4298df1b372e9455e0f51fc187 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Wed, 14 Sep 2022 20:37:55 +0200
Subject: [PATCH 06/12] gallium: split up req_local_mem

This will be required if a frontend has to request additional shared mem
on top of the shader declared one, but wants to create the CSO before
knowing the total amount.

In OpenCL applications can bind additional shared mem through kernel
arguments and this happens quite late.

Note: Clover sets the req_local_mem incorrectly before so we can leave it
as broken.

v2: fix panfrost code (Alyssa)

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 .../auxiliary/driver_trace/tr_dump_state.c    |  3 +-
 .../drivers/freedreno/a6xx/fd6_compute.c      |  8 ++-
 .../drivers/freedreno/ir3/ir3_gallium.c       |  2 +-
 src/gallium/drivers/iris/iris_program.c       |  2 +-
 src/gallium/drivers/iris/iris_state.c         |  2 +-
 src/gallium/drivers/llvmpipe/lp_state_cs.c    |  3 +-
 .../drivers/nouveau/nv50/nv50_compute.c       |  3 +-
 src/gallium/drivers/nouveau/nv50/nv50_state.c |  2 +-
 .../drivers/nouveau/nvc0/nvc0_compute.c       |  2 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c |  2 +-
 .../drivers/nouveau/nvc0/nve4_compute.c       | 18 +++---
 src/gallium/drivers/panfrost/pan_cmdstream.c  |  2 +-
 src/gallium/drivers/panfrost/pan_compute.c    |  2 +-
 src/gallium/drivers/r600/evergreen_compute.c  |  4 +-
 src/gallium/drivers/radeonsi/si_compute.c     | 57 ++++++++++++-------
 src/gallium/drivers/radeonsi/si_pipe.h        |  1 +
 src/gallium/drivers/softpipe/sp_compute.c     |  7 ++-
 src/gallium/drivers/svga/svga_pipe_cs.c       |  2 +-
 src/gallium/drivers/virgl/virgl_context.c     |  2 +-
 src/gallium/frontends/clover/core/kernel.cpp  |  5 +-
 src/gallium/frontends/lavapipe/lvp_pipeline.c |  2 +-
 src/gallium/frontends/rusticl/core/kernel.rs  | 18 ++++--
 .../frontends/rusticl/mesa/pipe/context.rs    | 13 ++++-
 src/gallium/include/pipe/p_state.h            |  9 ++-
 src/mesa/state_tracker/st_pbo_compute.c       |  4 +-
 src/mesa/state_tracker/st_program.c           |  2 +-
 26 files changed, 111 insertions(+), 66 deletions(-)

diff --git a/src/gallium/auxiliary/driver_trace/tr_dump_state.c b/src/gallium/auxiliary/driver_trace/tr_dump_state.c
index 410ac5a1abc8..20b507c4efb5 100644
--- a/src/gallium/auxiliary/driver_trace/tr_dump_state.c
+++ b/src/gallium/auxiliary/driver_trace/tr_dump_state.c
@@ -349,7 +349,7 @@ void trace_dump_compute_state(const struct pipe_compute_state *state)
    }
    trace_dump_member_end();
 
-   trace_dump_member(uint, state, req_local_mem);
+   trace_dump_member(uint, state, static_shared_mem);
    trace_dump_member(uint, state, req_input_mem);
 
    trace_dump_struct_end();
@@ -1081,6 +1081,7 @@ void trace_dump_grid_info(const struct pipe_grid_info *state)
 
    trace_dump_member(uint, state, pc);
    trace_dump_member(ptr, state, input);
+   trace_dump_member(uint, state, variable_shared_mem);
 
    trace_dump_member_begin("block");
    trace_dump_array(uint, state->block, ARRAY_SIZE(state->block));
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_compute.c b/src/gallium/drivers/freedreno/a6xx/fd6_compute.c
index 774e1603cb6c..9d9df192f945 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_compute.c
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_compute.c
@@ -42,7 +42,8 @@
 /* maybe move to fd6_program? */
 static void
 cs_program_emit(struct fd_context *ctx, struct fd_ringbuffer *ring,
-                struct ir3_shader_variant *v) assert_dt
+                struct ir3_shader_variant *v,
+                uint32_t variable_shared_size) assert_dt
 {
    const struct ir3_info *i = &v->info;
    enum a6xx_threadsize thrsz = i->double_threadsize ? THREAD128 : THREAD64;
@@ -71,7 +72,8 @@ cs_program_emit(struct fd_context *ctx, struct fd_ringbuffer *ring,
                COND(v->mergedregs, A6XX_SP_CS_CTRL_REG0_MERGEDREGS) |
                A6XX_SP_CS_CTRL_REG0_BRANCHSTACK(ir3_shader_branchstack_hw(v)));
 
-   uint32_t shared_size = MAX2(((int)v->cs.req_local_mem - 1) / 1024, 1);
+   uint32_t shared_size =
+      MAX2(((int)v->cs.req_local_mem + variable_shared_size- 1) / 1024, 1);
    OUT_PKT4(ring, REG_A6XX_SP_CS_UNKNOWN_A9B1, 1);
    OUT_RING(ring, A6XX_SP_CS_UNKNOWN_A9B1_SHARED_SIZE(shared_size) |
                      A6XX_SP_CS_UNKNOWN_A9B1_UNK6);
@@ -125,7 +127,7 @@ fd6_launch_grid(struct fd_context *ctx, const struct pipe_grid_info *info) in_dt
       return;
 
    if (ctx->dirty_shader[PIPE_SHADER_COMPUTE] & FD_DIRTY_SHADER_PROG)
-      cs_program_emit(ctx, ring, v);
+      cs_program_emit(ctx, ring, v, info->variable_shared_mem);
 
    fd6_emit_cs_state(ctx, ring, v);
    fd6_emit_cs_consts(v, ring, ctx, info);
diff --git a/src/gallium/drivers/freedreno/ir3/ir3_gallium.c b/src/gallium/drivers/freedreno/ir3/ir3_gallium.c
index 57788c2e788e..f2a574ac9c91 100644
--- a/src/gallium/drivers/freedreno/ir3/ir3_gallium.c
+++ b/src/gallium/drivers/freedreno/ir3/ir3_gallium.c
@@ -315,7 +315,7 @@ ir3_shader_compute_state_create(struct pipe_context *pctx,
                               .real_wavesize = IR3_SINGLE_OR_DOUBLE,
                           }, NULL);
    shader->cs.req_input_mem = align(cso->req_input_mem, 4) / 4;     /* byte->dword */
-   shader->cs.req_local_mem = cso->req_local_mem;
+   shader->cs.req_local_mem = cso->static_shared_mem;
 
    struct ir3_shader_state *hwcso = calloc(1, sizeof(*hwcso));
 
diff --git a/src/gallium/drivers/iris/iris_program.c b/src/gallium/drivers/iris/iris_program.c
index 4d909b8bb015..49f40ac4ef28 100644
--- a/src/gallium/drivers/iris/iris_program.c
+++ b/src/gallium/drivers/iris/iris_program.c
@@ -2534,7 +2534,7 @@ iris_create_compute_state(struct pipe_context *ctx,
    struct iris_uncompiled_shader *ish =
       iris_create_uncompiled_shader(screen, nir, NULL);
    ish->kernel_input_size = state->req_input_mem;
-   ish->kernel_shared_size = state->req_local_mem;
+   ish->kernel_shared_size = state->static_shared_mem;
 
    // XXX: disallow more than 64KB of shared variables
 
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index 3afb152a5c1b..f9fd3118e10c 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -7332,7 +7332,7 @@ iris_upload_gpgpu_walker(struct iris_context *ice,
 
       iris_pack_state(GENX(INTERFACE_DESCRIPTOR_DATA), desc, idd) {
          idd.SharedLocalMemorySize =
-            encode_slm_size(GFX_VER, ish->kernel_shared_size);
+            encode_slm_size(GFX_VER, ish->kernel_shared_size + grid->variable_shared_mem);
          idd.KernelStartPointer =
             KSP(shader) + brw_cs_prog_data_prog_offset(cs_prog_data,
                                                        dispatch.simd_size);
diff --git a/src/gallium/drivers/llvmpipe/lp_state_cs.c b/src/gallium/drivers/llvmpipe/lp_state_cs.c
index 22ac92e1fb7d..b82520ec2d26 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_cs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_cs.c
@@ -499,7 +499,6 @@ llvmpipe_create_compute_state(struct pipe_context *pipe,
    shader->no = cs_no++;
 
    shader->base.type = templ->ir_type;
-   shader->req_local_mem = templ->req_local_mem;
    if (templ->ir_type == PIPE_SHADER_IR_NIR_SERIALIZED) {
       struct blob_reader reader;
       const struct pipe_binary_program_header *hdr = templ->prog;
@@ -1416,7 +1415,7 @@ static void llvmpipe_launch_grid(struct pipe_context *pipe,
    job_info.block_size[1] = info->block[1];
    job_info.block_size[2] = info->block[2];
    job_info.work_dim = info->work_dim;
-   job_info.req_local_mem = llvmpipe->cs->req_local_mem;
+   job_info.req_local_mem = llvmpipe->cs->req_local_mem + info->variable_shared_mem;
    job_info.zero_initialize_shared_memory = llvmpipe->cs->zero_initialize_shared_memory;
    job_info.current = &llvmpipe->csctx->cs.current;
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_compute.c b/src/gallium/drivers/nouveau/nv50/nv50_compute.c
index 1213effd53d0..e6a597c8182f 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_compute.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_compute.c
@@ -579,8 +579,9 @@ nv50_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
    BEGIN_NV04(push, NV50_CP(CP_START_ID), 1);
    PUSH_DATA (push, cp->code_base);
 
+   int shared_size = cp->cp.smem_size + info->variable_shared_mem + cp->parm_size + 0x14;
    BEGIN_NV04(push, NV50_CP(SHARED_SIZE), 1);
-   PUSH_DATA (push, align(cp->cp.smem_size + cp->parm_size + 0x14, 0x40));
+   PUSH_DATA (push, align(shared_size, 0x40));
    BEGIN_NV04(push, NV50_CP(CP_REG_ALLOC_TEMP), 1);
    PUSH_DATA (push, cp->max_gpr);
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 0cdf2afacc9c..3161549c815c 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -861,7 +861,7 @@ nv50_cp_state_create(struct pipe_context *pipe,
       return NULL;
    }
 
-   prog->cp.smem_size = cso->req_local_mem;
+   prog->cp.smem_size = cso->static_shared_mem;
    prog->parm_size = cso->req_input_mem;
 
    return (void *)prog;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c b/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
index e9f0cbe77683..237b74ef4b5a 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
@@ -446,7 +446,7 @@ nvc0_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
    PUSH_DATA (push, 0x800); /* WARP_CSTACK_SIZE */
 
    BEGIN_NVC0(push, NVC0_CP(SHARED_SIZE), 3);
-   PUSH_DATA (push, align(cp->cp.smem_size, 0x100));
+   PUSH_DATA (push, align(cp->cp.smem_size + info->variable_shared_mem, 0x100));
    PUSH_DATA (push, info->block[0] * info->block[1] * info->block[2]);
    PUSH_DATA (push, cp->num_barriers);
    BEGIN_NVC0(push, NVC0_CP(CP_GPR_ALLOC), 1);
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index 4d4b5c431ea2..9eb442c3c102 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -741,7 +741,7 @@ nvc0_cp_state_create(struct pipe_context *pipe,
    prog->type = PIPE_SHADER_COMPUTE;
    prog->pipe.type = cso->ir_type;
 
-   prog->cp.smem_size = cso->req_local_mem;
+   prog->cp.smem_size = cso->static_shared_mem;
    prog->parm_size = cso->req_input_mem;
 
    switch(cso->ir_type) {
diff --git a/src/gallium/drivers/nouveau/nvc0/nve4_compute.c b/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
index 8758efd59c43..e673984bc871 100644
--- a/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
+++ b/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
@@ -627,6 +627,7 @@ nve4_compute_setup_launch_desc(struct nvc0_context *nvc0, uint32_t *qmd,
 {
    const struct nvc0_screen *screen = nvc0->screen;
    const struct nvc0_program *cp = nvc0->compprog;
+   uint32_t shared_size = cp->cp.smem_size + info->variable_shared_mem;
 
    NVA0C0_QMDV00_06_DEF_SET(qmd, INVALIDATE_TEXTURE_HEADER_CACHE, TRUE);
    NVA0C0_QMDV00_06_DEF_SET(qmd, INVALIDATE_TEXTURE_SAMPLER_CACHE, TRUE);
@@ -647,17 +648,16 @@ nve4_compute_setup_launch_desc(struct nvc0_context *nvc0, uint32_t *qmd,
    NVA0C0_QMDV00_06_VAL_SET(qmd, CTA_THREAD_DIMENSION1, info->block[1]);
    NVA0C0_QMDV00_06_VAL_SET(qmd, CTA_THREAD_DIMENSION2, info->block[2]);
 
-   NVA0C0_QMDV00_06_VAL_SET(qmd, SHARED_MEMORY_SIZE,
-                                 align(cp->cp.smem_size, 0x100));
+   NVA0C0_QMDV00_06_VAL_SET(qmd, SHARED_MEMORY_SIZE, align(shared_size, 0x100));
    NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE, cp->hdr[1] & 0xfffff0);
    NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_HIGH_SIZE, 0);
    NVA0C0_QMDV00_06_VAL_SET(qmd, SHADER_LOCAL_MEMORY_CRS_SIZE, 0x800);
 
-   if (cp->cp.smem_size > (32 << 10))
+   if (shared_size > (32 << 10))
       NVA0C0_QMDV00_06_DEF_SET(qmd, L1_CONFIGURATION,
                                     DIRECTLY_ADDRESSABLE_MEMORY_SIZE_48KB);
    else
-   if (cp->cp.smem_size > (16 << 10))
+   if (shared_size > (16 << 10))
       NVA0C0_QMDV00_06_DEF_SET(qmd, L1_CONFIGURATION,
                                     DIRECTLY_ADDRESSABLE_MEMORY_SIZE_32KB);
    else
@@ -690,6 +690,7 @@ gp100_compute_setup_launch_desc(struct nvc0_context *nvc0, uint32_t *qmd,
 {
    const struct nvc0_screen *screen = nvc0->screen;
    const struct nvc0_program *cp = nvc0->compprog;
+   uint32_t shared_size = cp->cp.smem_size + info->variable_shared_mem;
 
    NVC0C0_QMDV02_01_VAL_SET(qmd, SM_GLOBAL_CACHING_ENABLE, 1);
    NVC0C0_QMDV02_01_DEF_SET(qmd, RELEASE_MEMBAR_TYPE, FE_SYSMEMBAR);
@@ -705,8 +706,7 @@ gp100_compute_setup_launch_desc(struct nvc0_context *nvc0, uint32_t *qmd,
    NVC0C0_QMDV02_01_VAL_SET(qmd, CTA_THREAD_DIMENSION1, info->block[1]);
    NVC0C0_QMDV02_01_VAL_SET(qmd, CTA_THREAD_DIMENSION2, info->block[2]);
 
-   NVC0C0_QMDV02_01_VAL_SET(qmd, SHARED_MEMORY_SIZE,
-                                 align(cp->cp.smem_size, 0x100));
+   NVC0C0_QMDV02_01_VAL_SET(qmd, SHARED_MEMORY_SIZE, align(shared_size, 0x100));
    NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE, cp->hdr[1] & 0xfffff0);
    NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_HIGH_SIZE, 0);
    NVC0C0_QMDV02_01_VAL_SET(qmd, SHADER_LOCAL_MEMORY_CRS_SIZE, 0x800);
@@ -749,12 +749,12 @@ gv100_compute_setup_launch_desc(struct nvc0_context *nvc0, u32 *qmd,
    struct nvc0_program *cp = nvc0->compprog;
    struct nvc0_screen *screen = nvc0->screen;
    uint64_t entry = screen->text->offset + cp->code_base;
+   uint32_t shared_size = cp->cp.smem_size + info->variable_shared_mem;
 
    NVC3C0_QMDV02_02_VAL_SET(qmd, SM_GLOBAL_CACHING_ENABLE, 1);
    NVC3C0_QMDV02_02_DEF_SET(qmd, API_VISIBLE_CALL_LIMIT, NO_CHECK);
    NVC3C0_QMDV02_02_DEF_SET(qmd, SAMPLER_INDEX, INDEPENDENTLY);
-   NVC3C0_QMDV02_02_VAL_SET(qmd, SHARED_MEMORY_SIZE,
-                                  align(cp->cp.smem_size, 0x100));
+   NVC3C0_QMDV02_02_VAL_SET(qmd, SHARED_MEMORY_SIZE, align(shared_size, 0x100));
    NVC3C0_QMDV02_02_VAL_SET(qmd, SHADER_LOCAL_MEMORY_LOW_SIZE, cp->hdr[1] & 0xfffff0);
    NVC3C0_QMDV02_02_VAL_SET(qmd, SHADER_LOCAL_MEMORY_HIGH_SIZE, 0);
    NVC3C0_QMDV02_02_VAL_SET(qmd, MIN_SM_CONFIG_SHARED_MEM_SIZE,
@@ -764,7 +764,7 @@ gv100_compute_setup_launch_desc(struct nvc0_context *nvc0, u32 *qmd,
    NVC3C0_QMDV02_02_VAL_SET(qmd, QMD_VERSION, 2);
    NVC3C0_QMDV02_02_VAL_SET(qmd, QMD_MAJOR_VERSION, 2);
    NVC3C0_QMDV02_02_VAL_SET(qmd, TARGET_SM_CONFIG_SHARED_MEM_SIZE,
-                                  gv100_sm_config_smem_size(cp->cp.smem_size));
+                                  gv100_sm_config_smem_size(shared_size));
 
    NVC3C0_QMDV02_02_VAL_SET(qmd, CTA_RASTER_WIDTH, info->grid[0]);
    NVC3C0_QMDV02_02_VAL_SET(qmd, CTA_RASTER_HEIGHT, info->grid[1]);
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 8c403dc993f8..41fc76b26542 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -1623,7 +1623,7 @@ panfrost_emit_shared_memory(struct panfrost_batch *batch,
 
         struct pan_tls_info info = {
                 .tls.size = ss->info.tls_size,
-                .wls.size = ss->info.wls_size,
+                .wls.size = ss->info.wls_size + grid->variable_shared_mem,
                 .wls.instances = panfrost_choose_wls_instance_count(grid),
         };
 
diff --git a/src/gallium/drivers/panfrost/pan_compute.c b/src/gallium/drivers/panfrost/pan_compute.c
index 197e9b184324..409abee6854f 100644
--- a/src/gallium/drivers/panfrost/pan_compute.c
+++ b/src/gallium/drivers/panfrost/pan_compute.c
@@ -72,7 +72,7 @@ panfrost_create_compute_state(
 
         panfrost_shader_compile(pctx->screen, &ctx->shaders, &ctx->descs,
                                 deserialized ?: cso->prog,
-                                &ctx->base.debug, v, cso->req_local_mem);
+                                &ctx->base.debug, v, cso->static_shared_mem);
 
         /* There are no variants so we won't need the NIR again */
         ralloc_free(deserialized);
diff --git a/src/gallium/drivers/r600/evergreen_compute.c b/src/gallium/drivers/r600/evergreen_compute.c
index baef801d0ec6..8f22d2d5d152 100644
--- a/src/gallium/drivers/r600/evergreen_compute.c
+++ b/src/gallium/drivers/r600/evergreen_compute.c
@@ -435,7 +435,7 @@ static void *evergreen_create_compute_state(struct pipe_context *ctx,
 #endif
 
 	shader->ctx = rctx;
-	shader->local_size = cso->req_local_mem;
+	shader->local_size = cso->static_shared_mem;
 	shader->input_size = cso->req_input_mem;
 
 	shader->ir_type = cso->ir_type;
@@ -610,7 +610,7 @@ static void evergreen_emit_dispatch(struct r600_context *rctx,
 	unsigned num_pipes = rctx->screen->b.info.r600_max_quad_pipes;
 	unsigned wave_divisor = (16 * num_pipes);
 	int group_size = 1;
-	unsigned lds_size = shader->local_size / 4;
+	unsigned lds_size = (shader->local_size + info->variable_shared_mem) / 4;
 
 	if (shader->ir_type != PIPE_SHADER_IR_TGSI &&
 	    shader->ir_type != PIPE_SHADER_IR_NIR)
diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index 6bc9db5ce851..bc1f8cccfafe 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -240,7 +240,7 @@ static void *si_create_compute_state(struct pipe_context *ctx, const struct pipe
       si_const_and_shader_buffer_descriptors_idx(PIPE_SHADER_COMPUTE);
    sel->sampler_and_images_descriptors_index =
       si_sampler_and_image_descriptors_idx(PIPE_SHADER_COMPUTE);
-   sel->info.base.shared_size = cso->req_local_mem;
+   sel->info.base.shared_size = cso->static_shared_mem;
    program->shader.selector = &program->sel;
    program->shader.wave_size = si_determine_wave_size(sscreen, &program->shader);
    program->ir_type = cso->ir_type;
@@ -498,48 +498,64 @@ static bool si_setup_compute_scratch_buffer(struct si_context *sctx, struct si_s
 
 static bool si_switch_compute_shader(struct si_context *sctx, struct si_compute *program,
                                      struct si_shader *shader, const amd_kernel_code_t *code_object,
-                                     unsigned offset, bool *prefetch)
+                                     unsigned offset, bool *prefetch, unsigned variable_shared_size)
 {
    struct radeon_cmdbuf *cs = &sctx->gfx_cs;
-   struct ac_shader_config inline_config = {0};
-   struct ac_shader_config *config;
+   struct ac_shader_config config = {0};
    uint64_t shader_va;
+   unsigned stage = shader->selector->info.base.stage;
 
    *prefetch = false;
 
-   if (sctx->cs_shader_state.emitted_program == program && sctx->cs_shader_state.offset == offset)
+   assert(variable_shared_size == 0 || stage == MESA_SHADER_KERNEL || program->ir_type == PIPE_SHADER_IR_NATIVE);
+   if (sctx->cs_shader_state.emitted_program == program && sctx->cs_shader_state.offset == offset &&
+       sctx->cs_shader_state.variable_shared_size == variable_shared_size)
       return true;
 
+   /* copy the config, so we don't have to change it inside the si_shader object */
    if (program->ir_type != PIPE_SHADER_IR_NATIVE) {
-      config = &shader->config;
+      config = shader->config;
    } else {
+      code_object_to_config(code_object, &config);
+   }
+
+   /* only do this for OpenCL */
+   if (program->ir_type == PIPE_SHADER_IR_NATIVE || stage == MESA_SHADER_KERNEL) {
+      unsigned shared_size = program->sel.info.base.shared_size + variable_shared_size;
       unsigned lds_blocks;
 
-      config = &inline_config;
-      code_object_to_config(code_object, config);
+      /* Clover uses the compute API differently than other frontends and expects drivers to parse
+       * the shared_size out of the shader headers.
+       * Adding on top of the old value is fine though as Clover always creates a new CSO when it
+       * changes.
+       */
+      if (program->ir_type == PIPE_SHADER_IR_NATIVE) {
+         lds_blocks = config.lds_size;
+      } else {
+         lds_blocks = 0;
+      }
 
-      lds_blocks = config->lds_size;
       /* XXX: We are over allocating LDS.  For GFX6, the shader reports
        * LDS in blocks of 256 bytes, so if there are 4 bytes lds
        * allocated in the shader and 4 bytes allocated by the state
        * tracker, then we will set LDS_SIZE to 512 bytes rather than 256.
        */
       if (sctx->gfx_level <= GFX6) {
-         lds_blocks += align(program->sel.info.base.shared_size, 256) >> 8;
+         lds_blocks += align(shared_size, 256) >> 8;
       } else {
-         lds_blocks += align(program->sel.info.base.shared_size, 512) >> 9;
+         lds_blocks += align(shared_size, 512) >> 9;
       }
 
       /* TODO: use si_multiwave_lds_size_workaround */
       assert(lds_blocks <= 0xFF);
 
-      config->rsrc2 &= C_00B84C_LDS_SIZE;
-      config->rsrc2 |= S_00B84C_LDS_SIZE(lds_blocks);
+      config.rsrc2 &= C_00B84C_LDS_SIZE;
+      config.rsrc2 |= S_00B84C_LDS_SIZE(lds_blocks);
    }
 
    unsigned tmpring_size;
    ac_get_scratch_tmpring_size(&sctx->screen->info, true,
-                               config->scratch_bytes_per_wave,
+                               config.scratch_bytes_per_wave,
                                &sctx->max_seen_compute_scratch_bytes_per_wave, &tmpring_size);
 
    if (!si_setup_compute_scratch_buffer(sctx, shader))
@@ -576,19 +592,20 @@ static bool si_switch_compute_shader(struct si_context *sctx, struct si_compute
       radeon_set_sh_reg_seq(R_00B848_COMPUTE_PGM_RSRC1, 2);
    }
 
-   radeon_emit(config->rsrc1);
-   radeon_emit(config->rsrc2);
+   radeon_emit(config.rsrc1);
+   radeon_emit(config.rsrc2);
 
    COMPUTE_DBG(sctx->screen,
                "COMPUTE_PGM_RSRC1: 0x%08x "
                "COMPUTE_PGM_RSRC2: 0x%08x\n",
-               config->rsrc1, config->rsrc2);
+               config.rsrc1, config.rsrc2);
 
    radeon_set_sh_reg(R_00B860_COMPUTE_TMPRING_SIZE, tmpring_size);
    radeon_end();
 
    sctx->cs_shader_state.emitted_program = program;
    sctx->cs_shader_state.offset = offset;
+   sctx->cs_shader_state.variable_shared_size = variable_shared_size;
 
    *prefetch = true;
    return true;
@@ -675,7 +692,8 @@ static void si_setup_user_sgprs_co_v2(struct si_context *sctx, const amd_kernel_
       dispatch.grid_size_y = util_cpu_to_le32(info->grid[1] * info->block[1]);
       dispatch.grid_size_z = util_cpu_to_le32(info->grid[2] * info->block[2]);
 
-      dispatch.group_segment_size = util_cpu_to_le32(program->sel.info.base.shared_size);
+      dispatch.group_segment_size =
+         util_cpu_to_le32(program->sel.info.base.shared_size + info->variable_shared_mem);
 
       dispatch.kernarg_address = util_cpu_to_le64(kernel_args_va);
 
@@ -994,7 +1012,8 @@ static void si_launch_grid(struct pipe_context *ctx, const struct pipe_grid_info
 
    /* First emit registers. */
    bool prefetch;
-   if (!si_switch_compute_shader(sctx, program, &program->shader, code_object, info->pc, &prefetch))
+   if (!si_switch_compute_shader(sctx, program, &program->shader, code_object, info->pc, &prefetch,
+                                 info->variable_shared_mem))
       return;
 
    si_upload_compute_shader_descriptors(sctx);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 811f34075dbf..85b3ffe3739d 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -739,6 +739,7 @@ struct si_cs_shader_state {
    struct si_compute *program;
    struct si_compute *emitted_program;
    unsigned offset;
+   uint32_t variable_shared_size;
    bool initialized;
 };
 
diff --git a/src/gallium/drivers/softpipe/sp_compute.c b/src/gallium/drivers/softpipe/sp_compute.c
index 221ef7ec7975..2b70fb9777b2 100644
--- a/src/gallium/drivers/softpipe/sp_compute.c
+++ b/src/gallium/drivers/softpipe/sp_compute.c
@@ -184,8 +184,9 @@ softpipe_launch_grid(struct pipe_context *context,
 
    fill_grid_size(context, info, grid_size);
 
-   if (cs->shader.req_local_mem) {
-      local_mem = CALLOC(1, cs->shader.req_local_mem);
+   uint32_t shared_mem_size = cs->shader.static_shared_mem + info->variable_shared_mem;
+   if (shared_mem_size) {
+      local_mem = CALLOC(1, shared_mem_size);
    }
 
    machines = CALLOC(sizeof(struct tgsi_exec_machine *), num_threads_in_group);
@@ -202,7 +203,7 @@ softpipe_launch_grid(struct pipe_context *context,
             machines[idx] = tgsi_exec_machine_create(PIPE_SHADER_COMPUTE);
 
             machines[idx]->LocalMem = local_mem;
-            machines[idx]->LocalMemSize = cs->shader.req_local_mem;
+            machines[idx]->LocalMemSize = shared_mem_size;
             machines[idx]->NonHelperMask = (1 << (MIN2(TGSI_QUAD_SIZE, bwidth - local_x))) - 1;
             cs_prepare(cs, machines[idx],
                        local_x, local_y, local_z,
diff --git a/src/gallium/drivers/svga/svga_pipe_cs.c b/src/gallium/drivers/svga/svga_pipe_cs.c
index 7b2293863b78..428afd77c81f 100644
--- a/src/gallium/drivers/svga/svga_pipe_cs.c
+++ b/src/gallium/drivers/svga/svga_pipe_cs.c
@@ -70,7 +70,7 @@ svga_create_compute_state(struct pipe_context *pipe,
    /* Collect shader basic info */
    svga_tgsi_scan_shader(&cs->base);
 
-   cs->shared_mem_size = templ->req_local_mem;
+   cs->shared_mem_size = templ->static_shared_mem;
 
    SVGA_STATS_TIME_POP(svga_sws(svga));
    return cs;
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index dbd572da0ed5..c1ea961092d0 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -1440,7 +1440,7 @@ static void *virgl_create_compute_state(struct pipe_context *ctx,
    handle = virgl_object_assign_handle();
    ret = virgl_encode_shader_state(vctx, handle, PIPE_SHADER_COMPUTE,
                                    &so_info,
-                                   state->req_local_mem,
+                                   state->static_shared_mem,
                                    new_tokens);
    if (ret) {
       FREE((void *)ntt_tokens);
diff --git a/src/gallium/frontends/clover/core/kernel.cpp b/src/gallium/frontends/clover/core/kernel.cpp
index b07907e471b7..f1ff5a49b1ae 100644
--- a/src/gallium/frontends/clover/core/kernel.cpp
+++ b/src/gallium/frontends/clover/core/kernel.cpp
@@ -100,6 +100,7 @@ kernel::launch(command_queue &q,
    copy(pad_vector(q, reduced_grid_size, 1), info.grid);
    info.pc = find(name_equals(_name), b.syms).offset;
    info.input = exec.input.data();
+   info.variable_shared_mem = exec.mem_local;
 
    q.pipe->launch_grid(q.pipe, &info);
 
@@ -274,14 +275,14 @@ kernel::exec_context::bind(intrusive_ptr<command_queue> _q,
 
    // Create a new compute state if anything changed.
    if (!st || q != _q ||
-       cs.req_local_mem != mem_local ||
        cs.req_input_mem != input.size()) {
       if (st)
          _q->pipe->delete_compute_state(_q->pipe, st);
 
       cs.ir_type = q->device().ir_format();
       cs.prog = &(msec.data[0]);
-      cs.req_local_mem = mem_local;
+      // we only pass in NIRs or LLVMs and both IRs decode the size
+      cs.static_shared_mem = 0;
       cs.req_input_mem = input.size();
       st = q->pipe->create_compute_state(q->pipe, &cs);
       if (!st) {
diff --git a/src/gallium/frontends/lavapipe/lvp_pipeline.c b/src/gallium/frontends/lavapipe/lvp_pipeline.c
index 87d9da57764b..2efd36c9c45a 100644
--- a/src/gallium/frontends/lavapipe/lvp_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_pipeline.c
@@ -601,7 +601,7 @@ lvp_pipeline_compile_stage(struct lvp_pipeline *pipeline, nir_shader *nir)
       struct pipe_compute_state shstate = {0};
       shstate.prog = nir;
       shstate.ir_type = PIPE_SHADER_IR_NIR;
-      shstate.req_local_mem = nir->info.shared_size;
+      shstate.static_shared_mem = nir->info.shared_size;
       return device->queue.ctx->create_compute_state(device->queue.ctx, &shstate);
    } else {
       struct pipe_shader_state shstate = {0};
diff --git a/src/gallium/frontends/rusticl/core/kernel.rs b/src/gallium/frontends/rusticl/core/kernel.rs
index 5b2cf74d8716..bb94d1f24667 100644
--- a/src/gallium/frontends/rusticl/core/kernel.rs
+++ b/src/gallium/frontends/rusticl/core/kernel.rs
@@ -780,7 +780,9 @@ impl Kernel {
         let offsets = create_kernel_arr::<u64>(offsets, 0);
         let mut input: Vec<u8> = Vec::new();
         let mut resource_info = Vec::new();
-        let mut local_size: u64 = nir.shared_size() as u64;
+        // Set it once so we get the alignment padding right
+        let static_local_size: u64 = nir.shared_size() as u64;
+        let mut variable_local_size: u64 = static_local_size;
         let printf_size = q.device.printf_buffer_size() as u32;
         let mut samplers = Vec::new();
         let mut iviews = Vec::new();
@@ -836,9 +838,10 @@ impl Kernel {
                 KernelArgValue::LocalMem(size) => {
                     // TODO 32 bit
                     let pot = cmp::min(*size, 0x80);
-                    local_size = align(local_size, pot.next_power_of_two() as u64);
-                    input.extend_from_slice(&local_size.to_ne_bytes());
-                    local_size += *size as u64;
+                    variable_local_size =
+                        align(variable_local_size, pot.next_power_of_two() as u64);
+                    input.extend_from_slice(&variable_local_size.to_ne_bytes());
+                    variable_local_size += *size as u64;
                 }
                 KernelArgValue::Sampler(sampler) => {
                     samplers.push(sampler.pipe());
@@ -853,6 +856,9 @@ impl Kernel {
             }
         }
 
+        // subtract the shader local_size as we only request something on top of that.
+        variable_local_size -= nir.shared_size() as u64;
+
         let mut printf_buf = None;
         for arg in &self.internal_args {
             if arg.offset > input.len() {
@@ -937,7 +943,7 @@ impl Kernel {
                     init_data.len() as u32,
                 );
             }
-            let cso = ctx.create_compute_state(nir, local_size as u32);
+            let cso = ctx.create_compute_state(nir, static_local_size as u32);
 
             ctx.bind_compute_state(cso);
             ctx.bind_sampler_states(&samplers);
@@ -946,7 +952,7 @@ impl Kernel {
             ctx.set_global_binding(resources.as_slice(), &mut globals);
             ctx.set_constant_buffer(0, &input);
 
-            ctx.launch_grid(work_dim, block, grid);
+            ctx.launch_grid(work_dim, block, grid, variable_local_size as u32);
 
             ctx.clear_global_binding(globals.len() as u32);
             ctx.clear_shader_images(iviews.len() as u32);
diff --git a/src/gallium/frontends/rusticl/mesa/pipe/context.rs b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
index bda36c41e8c4..c1275554c59e 100644
--- a/src/gallium/frontends/rusticl/mesa/pipe/context.rs
+++ b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
@@ -265,12 +265,12 @@ impl PipeContext {
         unsafe { self.pipe.as_ref().texture_unmap.unwrap()(self.pipe.as_ptr(), tx) };
     }
 
-    pub fn create_compute_state(&self, nir: &NirShader, local_mem: u32) -> *mut c_void {
+    pub fn create_compute_state(&self, nir: &NirShader, static_local_mem: u32) -> *mut c_void {
         let state = pipe_compute_state {
             ir_type: pipe_shader_ir::PIPE_SHADER_IR_NIR,
             prog: nir.dup_for_driver().cast(),
             req_input_mem: 0,
-            req_local_mem: local_mem,
+            static_shared_mem: static_local_mem,
         };
         unsafe { self.pipe.as_ref().create_compute_state.unwrap()(self.pipe.as_ptr(), &state) }
     }
@@ -334,10 +334,17 @@ impl PipeContext {
         }
     }
 
-    pub fn launch_grid(&self, work_dim: u32, block: [u32; 3], grid: [u32; 3]) {
+    pub fn launch_grid(
+        &self,
+        work_dim: u32,
+        block: [u32; 3],
+        grid: [u32; 3],
+        variable_local_mem: u32,
+    ) {
         let info = pipe_grid_info {
             pc: 0,
             input: ptr::null(),
+            variable_shared_mem: variable_local_mem,
             work_dim: work_dim,
             block: block,
             last_block: [0; 3],
diff --git a/src/gallium/include/pipe/p_state.h b/src/gallium/include/pipe/p_state.h
index 34154cef08e7..4fe3db90794d 100644
--- a/src/gallium/include/pipe/p_state.h
+++ b/src/gallium/include/pipe/p_state.h
@@ -936,6 +936,13 @@ struct pipe_grid_info
     */
    const void *input;
 
+   /**
+    * Variable shared memory used by this invocation.
+    *
+    * This comes on top of shader declared shared memory.
+    */
+   uint32_t variable_shared_mem;
+
    /**
     * Grid number of dimensions, 1-3, e.g. the work_dim parameter passed to
     * clEnqueueNDRangeKernel. Note block[] and grid[] must be padded with
@@ -1005,7 +1012,7 @@ struct pipe_compute_state
 {
    enum pipe_shader_ir ir_type; /**< IR type contained in prog. */
    const void *prog; /**< Compute program to be executed. */
-   unsigned req_local_mem; /**< Required size of the LOCAL resource. */
+   unsigned static_shared_mem; /**< equal to info.shared_size, used for shaders passed as TGSI */
    unsigned req_input_mem; /**< Required size of the INPUT resource. */
 };
 
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 45a06d9c192f..fc8bc3785fcc 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -942,7 +942,7 @@ download_texture_compute(struct st_context *st,
             assert(async->nir && !async->cs);
             struct pipe_compute_state state = {0};
             state.ir_type = PIPE_SHADER_IR_NIR;
-            state.req_local_mem = async->nir->info.shared_size;
+            state.static_shared_mem = async->nir->info.shared_size;
             state.prog = async->nir;
             async->nir = NULL;
             async->cs = pipe->create_compute_state(pipe, &state);
@@ -957,7 +957,7 @@ download_texture_compute(struct st_context *st,
                if (!spec->cs) {
                   struct pipe_compute_state state = {0};
                   state.ir_type = PIPE_SHADER_IR_NIR;
-                  state.req_local_mem = spec->nir->info.shared_size;
+                  state.static_shared_mem = spec->nir->info.shared_size;
                   state.prog = spec->nir;
                   spec->nir = NULL;
                   spec->cs = pipe->create_compute_state(pipe, &state);
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 376a5f6621eb..ff784a448035 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -549,7 +549,7 @@ st_create_nir_shader(struct st_context *st, struct pipe_shader_state *state)
    case MESA_SHADER_COMPUTE: {
       struct pipe_compute_state cs = {0};
       cs.ir_type = state->type;
-      cs.req_local_mem = info.shared_size;
+      cs.static_shared_mem = info.shared_size;
 
       if (state->type == PIPE_SHADER_IR_NIR)
          cs.prog = state->ir.nir;
-- 
GitLab


From a68284e170eb1e6e763bd20898bbf01efd4e6fc4 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Sat, 17 Sep 2022 19:59:56 +0200
Subject: [PATCH 07/12] iris: invalidate sysvals if grid dimension changes

Cc: mesa-stable
Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
Reviewed-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/iris/iris_context.c | 1 +
 src/gallium/drivers/iris/iris_context.h | 2 ++
 src/gallium/drivers/iris/iris_draw.c    | 6 ++++++
 3 files changed, 9 insertions(+)

diff --git a/src/gallium/drivers/iris/iris_context.c b/src/gallium/drivers/iris/iris_context.c
index 70dd21176a41..3d4f2e13daaf 100644
--- a/src/gallium/drivers/iris/iris_context.c
+++ b/src/gallium/drivers/iris/iris_context.c
@@ -83,6 +83,7 @@ iris_lost_context_state(struct iris_batch *batch)
    memset(&ice->shaders.urb, 0, sizeof(ice->shaders.urb));
    memset(ice->state.last_block, 0, sizeof(ice->state.last_block));
    memset(ice->state.last_grid, 0, sizeof(ice->state.last_grid));
+   ice->state.last_grid_dim = 0;
    batch->last_binder_address = ~0ull;
    batch->last_aux_map_state = 0;
    batch->screen->vtbl.lost_genx_state(ice, batch);
diff --git a/src/gallium/drivers/iris/iris_context.h b/src/gallium/drivers/iris/iris_context.h
index 0c3841fc2ff5..1bd97a48258a 100644
--- a/src/gallium/drivers/iris/iris_context.h
+++ b/src/gallium/drivers/iris/iris_context.h
@@ -753,6 +753,8 @@ struct iris_context {
 
       /** The last compute grid size */
       uint32_t last_grid[3];
+      /** The last compute grid dimensions */
+      uint32_t last_grid_dim;
       /** Reference to the BO containing the compute grid size */
       struct iris_state_ref grid_size;
       /** Reference to the SURFACE_STATE for the compute grid resource */
diff --git a/src/gallium/drivers/iris/iris_draw.c b/src/gallium/drivers/iris/iris_draw.c
index 2bf23ab1b3e6..04680097d80a 100644
--- a/src/gallium/drivers/iris/iris_draw.c
+++ b/src/gallium/drivers/iris/iris_draw.c
@@ -408,6 +408,12 @@ iris_launch_grid(struct pipe_context *ctx, const struct pipe_grid_info *grid)
       ice->state.shaders[MESA_SHADER_COMPUTE].sysvals_need_upload = true;
    }
 
+   if (ice->state.last_grid_dim != grid->work_dim) {
+      ice->state.last_grid_dim = grid->work_dim;
+      ice->state.stage_dirty |= IRIS_STAGE_DIRTY_CONSTANTS_CS;
+      ice->state.shaders[MESA_SHADER_COMPUTE].sysvals_need_upload = true;
+   }
+
    iris_update_grid_size_resource(ice, grid);
 
    iris_binder_reserve_compute(ice);
-- 
GitLab


From 908361ebb2925c1373820ca7255ee8fcfb46c37c Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Sat, 17 Sep 2022 17:54:55 +0200
Subject: [PATCH 08/12] rusticl: unbind compute state before deleting

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
---
 src/gallium/frontends/rusticl/core/kernel.rs | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/frontends/rusticl/core/kernel.rs b/src/gallium/frontends/rusticl/core/kernel.rs
index bb94d1f24667..745336e4f141 100644
--- a/src/gallium/frontends/rusticl/core/kernel.rs
+++ b/src/gallium/frontends/rusticl/core/kernel.rs
@@ -958,6 +958,7 @@ impl Kernel {
             ctx.clear_shader_images(iviews.len() as u32);
             ctx.clear_sampler_views(sviews.len() as u32);
             ctx.clear_sampler_states(samplers.len() as u32);
+            ctx.bind_compute_state(ptr::null_mut());
             ctx.delete_compute_state(cso);
             ctx.memory_barrier(PIPE_BARRIER_GLOBAL_BUFFER);
 
-- 
GitLab


From b083ae44035fba65d4873c362aa3eeaa6d3b5105 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Thu, 15 Sep 2022 01:30:32 +0200
Subject: [PATCH 09/12] rusticl: create the CSO ahead of launches

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
---
 src/gallium/frontends/rusticl/core/device.rs | 15 ++++
 src/gallium/frontends/rusticl/core/kernel.rs | 72 +++++++++++++++++---
 2 files changed, 76 insertions(+), 11 deletions(-)

diff --git a/src/gallium/frontends/rusticl/core/device.rs b/src/gallium/frontends/rusticl/core/device.rs
index 88c21e950001..b8f1a2d9dff9 100644
--- a/src/gallium/frontends/rusticl/core/device.rs
+++ b/src/gallium/frontends/rusticl/core/device.rs
@@ -73,6 +73,9 @@ pub trait HelperContextWrapper {
 
     fn texture_map_coherent(&self, res: &PipeResource, bx: &pipe_box, rw: RWFlags) -> PipeTransfer;
 
+    fn create_compute_state(&self, nir: &NirShader, static_local_mem: u32) -> *mut c_void;
+    fn delete_compute_state(&self, cso: *mut c_void);
+
     fn unmap(&self, tx: PipeTransfer);
 }
 
@@ -148,6 +151,14 @@ impl<'a> HelperContextWrapper for HelperContext<'a> {
             .texture_map(res, bx, rw, ResourceMapType::Coherent)
     }
 
+    fn create_compute_state(&self, nir: &NirShader, static_local_mem: u32) -> *mut c_void {
+        self.lock.create_compute_state(nir, static_local_mem)
+    }
+
+    fn delete_compute_state(&self, cso: *mut c_void) {
+        self.lock.delete_compute_state(cso)
+    }
+
     fn unmap(&self, tx: PipeTransfer) {
         tx.with_ctx(&self.lock);
     }
@@ -727,6 +738,10 @@ impl Device {
         id as u32
     }
 
+    pub fn shareable_shaders(&self) -> bool {
+        self.screen.param(pipe_cap::PIPE_CAP_SHAREABLE_SHADERS) == 1
+    }
+
     pub fn helper_ctx(&self) -> impl HelperContextWrapper + '_ {
         HelperContext {
             lock: self.helper_ctx.lock().unwrap(),
diff --git a/src/gallium/frontends/rusticl/core/kernel.rs b/src/gallium/frontends/rusticl/core/kernel.rs
index 745336e4f141..43cd7ab01e54 100644
--- a/src/gallium/frontends/rusticl/core/kernel.rs
+++ b/src/gallium/frontends/rusticl/core/kernel.rs
@@ -242,6 +242,48 @@ impl InternalKernelArg {
     }
 }
 
+struct KernelDevStateInner {
+    nir: NirShader,
+    cso: *mut c_void,
+}
+
+struct KernelDevState {
+    states: HashMap<Arc<Device>, KernelDevStateInner>,
+}
+
+impl Drop for KernelDevState {
+    fn drop(&mut self) {
+        self.states.iter().for_each(|(dev, dev_state)| {
+            if !dev_state.cso.is_null() {
+                dev.helper_ctx().delete_compute_state(dev_state.cso);
+            }
+        })
+    }
+}
+
+impl KernelDevState {
+    fn new(nirs: HashMap<Arc<Device>, NirShader>) -> Arc<Self> {
+        let states = nirs
+            .into_iter()
+            .map(|(dev, nir)| {
+                let cso = if dev.shareable_shaders() {
+                    dev.helper_ctx()
+                        .create_compute_state(&nir, nir.shared_size())
+                } else {
+                    ptr::null_mut()
+                };
+                (dev, KernelDevStateInner { nir: nir, cso: cso })
+            })
+            .collect();
+
+        Arc::new(Self { states: states })
+    }
+
+    fn get(&self, dev: &Device) -> &KernelDevStateInner {
+        self.states.get(dev).unwrap()
+    }
+}
+
 #[repr(C)]
 pub struct Kernel {
     pub base: CLObjectBase<CL_INVALID_KERNEL>,
@@ -252,7 +294,7 @@ pub struct Kernel {
     pub work_group_size: [usize; 3],
     pub attributes_string: String,
     internal_args: Vec<InternalKernelArg>,
-    nirs: HashMap<Arc<Device>, NirShader>,
+    dev_state: Arc<KernelDevState>,
 }
 
 impl_cl_type_trait!(cl_kernel, Kernel, CL_INVALID_KERNEL);
@@ -759,8 +801,7 @@ impl Kernel {
             attributes_string: attributes_string,
             values: values,
             internal_args: internal_args,
-            // caller has to verify all kernels have the same sig
-            nirs: nirs,
+            dev_state: KernelDevState::new(nirs),
         })
     }
 
@@ -774,7 +815,7 @@ impl Kernel {
         grid: &[usize],
         offsets: &[usize],
     ) -> CLResult<EventSig> {
-        let nir = self.nirs.get(&q.device).unwrap();
+        let nir = &self.dev_state.get(&q.device).nir;
         let mut block = create_kernel_arr::<u32>(block, 1);
         let mut grid = create_kernel_arr::<u32>(grid, 1);
         let offsets = create_kernel_arr::<u64>(offsets, 0);
@@ -914,11 +955,11 @@ impl Kernel {
 
         let k = Arc::clone(self);
         Ok(Box::new(move |q, ctx| {
-            let nir = k.nirs.get(&q.device).unwrap();
+            let dev_state = k.dev_state.get(&q.device);
             let mut input = input.clone();
             let mut resources = Vec::with_capacity(resource_info.len());
             let mut globals: Vec<*mut u32> = Vec::new();
-            let printf_format = nir.printf_format();
+            let printf_format = dev_state.nir.printf_format();
 
             let mut sviews: Vec<_> = sviews
                 .iter()
@@ -943,7 +984,12 @@ impl Kernel {
                     init_data.len() as u32,
                 );
             }
-            let cso = ctx.create_compute_state(nir, static_local_size as u32);
+
+            let cso = if dev_state.cso.is_null() {
+                ctx.create_compute_state(&dev_state.nir, static_local_size as u32)
+            } else {
+                dev_state.cso
+            };
 
             ctx.bind_compute_state(cso);
             ctx.bind_sampler_states(&samplers);
@@ -958,8 +1004,12 @@ impl Kernel {
             ctx.clear_shader_images(iviews.len() as u32);
             ctx.clear_sampler_views(sviews.len() as u32);
             ctx.clear_sampler_states(samplers.len() as u32);
+
             ctx.bind_compute_state(ptr::null_mut());
-            ctx.delete_compute_state(cso);
+            if dev_state.cso.is_null() {
+                ctx.delete_compute_state(cso);
+            }
+
             ctx.memory_barrier(PIPE_BARRIER_GLOBAL_BUFFER);
 
             samplers.iter().for_each(|s| ctx.delete_sampler_state(*s));
@@ -1060,12 +1110,12 @@ impl Kernel {
     }
 
     pub fn priv_mem_size(&self, dev: &Arc<Device>) -> cl_ulong {
-        self.nirs.get(dev).unwrap().scratch_size() as cl_ulong
+        self.dev_state.get(dev).nir.scratch_size() as cl_ulong
     }
 
     pub fn local_mem_size(&self, dev: &Arc<Device>) -> cl_ulong {
         // TODO include args
-        self.nirs.get(dev).unwrap().shared_size() as cl_ulong
+        self.dev_state.get(dev).nir.shared_size() as cl_ulong
     }
 }
 
@@ -1080,7 +1130,7 @@ impl Clone for Kernel {
             work_group_size: self.work_group_size,
             attributes_string: self.attributes_string.clone(),
             internal_args: self.internal_args.clone(),
-            nirs: self.nirs.clone(),
+            dev_state: self.dev_state.clone(),
         }
     }
 }
-- 
GitLab


From 810b0289cd9ec510ff865c8b22f0b7a19ecbaa27 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Thu, 15 Sep 2022 01:53:26 +0200
Subject: [PATCH 10/12] rusticl: create the constant buffer ahead of launches

v2: don't bind a const buffer if there is none

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
---
 src/gallium/frontends/rusticl/core/kernel.rs | 56 +++++++++++++-------
 1 file changed, 38 insertions(+), 18 deletions(-)

diff --git a/src/gallium/frontends/rusticl/core/kernel.rs b/src/gallium/frontends/rusticl/core/kernel.rs
index 43cd7ab01e54..3e807998b98c 100644
--- a/src/gallium/frontends/rusticl/core/kernel.rs
+++ b/src/gallium/frontends/rusticl/core/kernel.rs
@@ -12,6 +12,7 @@ use mesa_rust::compiler::clc::*;
 use mesa_rust::compiler::nir::*;
 use mesa_rust::pipe::context::RWFlags;
 use mesa_rust::pipe::context::ResourceMapType;
+use mesa_rust::pipe::resource::*;
 use mesa_rust::pipe::screen::ResourceType;
 use mesa_rust_gen::*;
 use mesa_rust_util::math::*;
@@ -244,6 +245,7 @@ impl InternalKernelArg {
 
 struct KernelDevStateInner {
     nir: NirShader,
+    constant_buffer: Option<Arc<PipeResource>>,
     cso: *mut c_void,
 }
 
@@ -272,13 +274,43 @@ impl KernelDevState {
                 } else {
                     ptr::null_mut()
                 };
-                (dev, KernelDevStateInner { nir: nir, cso: cso })
+
+                let cb = Self::create_nir_constant_buffer(&dev, &nir);
+
+                (
+                    dev,
+                    KernelDevStateInner {
+                        nir: nir,
+                        constant_buffer: cb,
+                        cso: cso,
+                    },
+                )
             })
             .collect();
 
         Arc::new(Self { states: states })
     }
 
+    fn create_nir_constant_buffer(dev: &Device, nir: &NirShader) -> Option<Arc<PipeResource>> {
+        let buf = nir.get_constant_buffer();
+        let len = buf.len() as u32;
+
+        if len > 0 {
+            let res = dev
+                .screen()
+                .resource_create_buffer(len, ResourceType::Normal)
+                .unwrap();
+
+            dev.helper_ctx()
+                .exec(|ctx| ctx.buffer_subdata(&res, 0, buf.as_ptr().cast(), len))
+                .wait();
+
+            Some(Arc::new(res))
+        } else {
+            None
+        }
+    }
+
     fn get(&self, dev: &Device) -> &KernelDevStateInner {
         self.states.get(dev).unwrap()
     }
@@ -815,14 +847,14 @@ impl Kernel {
         grid: &[usize],
         offsets: &[usize],
     ) -> CLResult<EventSig> {
-        let nir = &self.dev_state.get(&q.device).nir;
+        let dev_state = self.dev_state.get(&q.device);
         let mut block = create_kernel_arr::<u32>(block, 1);
         let mut grid = create_kernel_arr::<u32>(grid, 1);
         let offsets = create_kernel_arr::<u64>(offsets, 0);
         let mut input: Vec<u8> = Vec::new();
         let mut resource_info = Vec::new();
         // Set it once so we get the alignment padding right
-        let static_local_size: u64 = nir.shared_size() as u64;
+        let static_local_size: u64 = dev_state.nir.shared_size() as u64;
         let mut variable_local_size: u64 = static_local_size;
         let printf_size = q.device.printf_buffer_size() as u32;
         let mut samplers = Vec::new();
@@ -898,7 +930,7 @@ impl Kernel {
         }
 
         // subtract the shader local_size as we only request something on top of that.
-        variable_local_size -= nir.shared_size() as u64;
+        variable_local_size -= dev_state.nir.shared_size() as u64;
 
         let mut printf_buf = None;
         for arg in &self.internal_args {
@@ -907,21 +939,9 @@ impl Kernel {
             }
             match arg.kind {
                 InternalKernelArgType::ConstantBuffer => {
+                    assert!(dev_state.constant_buffer.is_some());
                     input.extend_from_slice(&[0; 8]);
-                    let buf = nir.get_constant_buffer();
-                    let res = Arc::new(
-                        q.device
-                            .screen()
-                            .resource_create_buffer(buf.len() as u32, ResourceType::Normal)
-                            .unwrap(),
-                    );
-                    q.device
-                        .helper_ctx()
-                        .exec(|ctx| {
-                            ctx.buffer_subdata(&res, 0, buf.as_ptr().cast(), buf.len() as u32)
-                        })
-                        .wait();
-                    resource_info.push((Some(res), arg.offset));
+                    resource_info.push((dev_state.constant_buffer.clone(), arg.offset));
                 }
                 InternalKernelArgType::GlobalWorkOffsets => {
                     input.extend_from_slice(&cl_prop::<[u64; 3]>(offsets));
-- 
GitLab


From e9f6b7c06b81e7a20ca9e356d7915aa5e5a07ac5 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@collabora.com>
Date: Mon, 19 Sep 2022 11:06:12 -0400
Subject: [PATCH 11/12] panfrost: Don't merge workgroups with variable shared
 mem

If nir->info.shared_size = 0 but grid->variable_shared_mem > 0, the shader uses
shared memory but the compiler may not realize that. We need to disable
workgroup merging even in this case. The alternate approach is to statically
check for shared intrinsics in the compiler, but this is a bit easier all things
considered.

Signed-off-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/drivers/panfrost/pan_cmdstream.c | 11 ++++++++++-
 src/panfrost/util/pan_ir.h                   |  5 ++++-
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 41fc76b26542..84aae30b1209 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -4251,7 +4251,16 @@ panfrost_launch_grid(struct pipe_context *pipe,
                                      batch->rsd[PIPE_SHADER_COMPUTE],
                                      panfrost_emit_shared_memory(batch, info));
 
-                cfg.allow_merging_workgroups = cs->info.cs.allow_merging_workgroups;
+                /* Workgroups may be merged if the shader does not use barriers
+                 * or shared memory. This condition is checked against the
+                 * static shared_size at compile-time. We need to check the
+                 * variable shared size at launch_grid time, because the
+                 * compiler doesn't know about that.
+                 */
+                cfg.allow_merging_workgroups =
+                        cs->info.cs.allow_merging_workgroups &&
+                        (info->variable_shared_mem == 0);
+
                 cfg.task_increment = 1;
                 cfg.task_axis = MALI_TASK_AXIS_Z;
         }
diff --git a/src/panfrost/util/pan_ir.h b/src/panfrost/util/pan_ir.h
index 4e1732cf80ae..ffa5802620b2 100644
--- a/src/panfrost/util/pan_ir.h
+++ b/src/panfrost/util/pan_ir.h
@@ -335,7 +335,10 @@ struct pan_shader_info {
 
                 struct {
                         /* Is it legal to merge workgroups? This is true if the
-                         * shader uses neither barriers nor shared memory.
+                         * shader uses neither barriers nor shared memory. This
+                         * requires caution: if the API allows specifying shared
+                         * memory at launch time (instead of compile time), that
+                         * memory will not be accounted for by the compiler.
                          *
                          * Used by the Valhall hardware.
                          */
-- 
GitLab


From 0851d0f2109caa4359c523f64fcc293b93c0e696 Mon Sep 17 00:00:00 2001
From: Karol Herbst <kherbst@redhat.com>
Date: Thu, 22 Sep 2022 13:14:42 +0200
Subject: [PATCH 12/12] rusticl: remove Option from set_global_binding

We never bind NULL resources through set_global_binding and drivers depend
on this behaviour already.

Signed-off-by: Karol Herbst <kherbst@redhat.com>
Reviewed-by: Alyssa Rosenzweig <alyssa@collabora.com>
---
 src/gallium/frontends/rusticl/core/kernel.rs       | 6 +++---
 src/gallium/frontends/rusticl/mesa/pipe/context.rs | 7 ++-----
 2 files changed, 5 insertions(+), 8 deletions(-)

diff --git a/src/gallium/frontends/rusticl/core/kernel.rs b/src/gallium/frontends/rusticl/core/kernel.rs
index 3e807998b98c..d61c03ee671c 100644
--- a/src/gallium/frontends/rusticl/core/kernel.rs
+++ b/src/gallium/frontends/rusticl/core/kernel.rs
@@ -885,7 +885,7 @@ impl Kernel {
                     let res = mem.get_res_of_dev(&q.device)?;
                     if mem.is_buffer() {
                         input.extend_from_slice(&mem.offset.to_ne_bytes());
-                        resource_info.push((Some(res.clone()), arg.offset));
+                        resource_info.push((res.clone(), arg.offset));
                     } else {
                         let format = mem.image_format.to_pipe_format().unwrap();
                         let (formats, orders) = if arg.kind == KernelArgType::Image {
@@ -941,7 +941,7 @@ impl Kernel {
                 InternalKernelArgType::ConstantBuffer => {
                     assert!(dev_state.constant_buffer.is_some());
                     input.extend_from_slice(&[0; 8]);
-                    resource_info.push((dev_state.constant_buffer.clone(), arg.offset));
+                    resource_info.push((dev_state.constant_buffer.clone().unwrap(), arg.offset));
                 }
                 InternalKernelArgType::GlobalWorkOffsets => {
                     input.extend_from_slice(&cl_prop::<[u64; 3]>(offsets));
@@ -955,7 +955,7 @@ impl Kernel {
                     );
 
                     input.extend_from_slice(&[0; 8]);
-                    resource_info.push((Some(buf.clone()), arg.offset));
+                    resource_info.push((buf.clone(), arg.offset));
 
                     printf_buf = Some(buf);
                 }
diff --git a/src/gallium/frontends/rusticl/mesa/pipe/context.rs b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
index c1275554c59e..0df09a25f1a0 100644
--- a/src/gallium/frontends/rusticl/mesa/pipe/context.rs
+++ b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
@@ -356,11 +356,8 @@ impl PipeContext {
         unsafe { self.pipe.as_ref().launch_grid.unwrap()(self.pipe.as_ptr(), &info) }
     }
 
-    pub fn set_global_binding(&self, res: &[Option<Arc<PipeResource>>], out: &mut [*mut u32]) {
-        let mut res: Vec<_> = res
-            .iter()
-            .map(|o| o.as_ref().map_or(ptr::null_mut(), |r| r.pipe()))
-            .collect();
+    pub fn set_global_binding(&self, res: &[Arc<PipeResource>], out: &mut [*mut u32]) {
+        let mut res: Vec<_> = res.iter().map(|r| r.pipe()).collect();
         unsafe {
             self.pipe.as_ref().set_global_binding.unwrap()(
                 self.pipe.as_ptr(),
-- 
GitLab

