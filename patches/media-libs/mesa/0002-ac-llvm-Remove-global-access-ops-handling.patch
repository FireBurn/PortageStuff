From d7f8d48e1e207f6cc8c520d7e5cf0cdc235839f2 Mon Sep 17 00:00:00 2001
From: Mike Lothian <mike@fireburn.co.uk>
Date: Sun, 19 May 2024 20:59:04 +0100
Subject: [PATCH 2/2] ac/llvm: Remove global access ops handling

They have been lowered in nir

Signed-off-by: Mike Lothian <mike@fireburn.co.uk>
---
 src/amd/llvm/ac_nir_to_llvm.c | 138 ----------------------------------
 1 file changed, 138 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 797d1c4742d..340f2335000 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -1972,129 +1972,6 @@ static LLVMValueRef enter_waterfall_ubo(struct ac_nir_context *ctx, struct water
                           nir_intrinsic_access(instr) & ACCESS_NON_UNIFORM);
 }
 
-static LLVMValueRef get_global_address(struct ac_nir_context *ctx,
-                                       nir_intrinsic_instr *instr,
-                                       LLVMTypeRef type)
-{
-   bool is_store = instr->intrinsic == nir_intrinsic_store_global ||
-                   instr->intrinsic == nir_intrinsic_store_global_amd;
-   LLVMValueRef addr = get_src(ctx, instr->src[is_store ? 1 : 0]);
-
-   LLVMTypeRef ptr_type = LLVMPointerType(type, AC_ADDR_SPACE_GLOBAL);
-
-   if (nir_intrinsic_has_base(instr)) {
-      /* _amd variants */
-      uint32_t base = nir_intrinsic_base(instr);
-      unsigned num_src = nir_intrinsic_infos[instr->intrinsic].num_srcs;
-      LLVMValueRef offset = get_src(ctx, instr->src[num_src - 1]);
-      offset = LLVMBuildAdd(ctx->ac.builder, offset, LLVMConstInt(ctx->ac.i32, base, false), "");
-
-      LLVMTypeRef i8_ptr_type = LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_GLOBAL);
-      addr = LLVMBuildIntToPtr(ctx->ac.builder, addr, i8_ptr_type, "");
-      addr = LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, addr, &offset, 1, "");
-      return LLVMBuildPointerCast(ctx->ac.builder, addr, ptr_type, "");
-   } else {
-      return LLVMBuildIntToPtr(ctx->ac.builder, addr, ptr_type, "");
-   }
-}
-
-static LLVMValueRef visit_load_global(struct ac_nir_context *ctx,
-                                      nir_intrinsic_instr *instr)
-{
-   LLVMTypeRef result_type = get_def_type(ctx, &instr->def);
-   LLVMValueRef val;
-   LLVMValueRef addr = get_global_address(ctx, instr, result_type);
-
-   val = LLVMBuildLoad2(ctx->ac.builder, result_type, addr, "");
-
-   if (nir_intrinsic_access(instr) & (ACCESS_COHERENT | ACCESS_VOLATILE)) {
-      LLVMSetOrdering(val, LLVMAtomicOrderingMonotonic);
-      LLVMSetAlignment(val, ac_get_type_size(result_type));
-   }
-
-   return val;
-}
-
-static void visit_store_global(struct ac_nir_context *ctx,
-				     nir_intrinsic_instr *instr)
-{
-   LLVMValueRef data = get_src(ctx, instr->src[0]);
-   LLVMTypeRef type = LLVMTypeOf(data);
-   LLVMValueRef addr = get_global_address(ctx, instr, type);
-   LLVMValueRef val;
-
-   val = LLVMBuildStore(ctx->ac.builder, data, addr);
-
-   if (nir_intrinsic_access(instr) & (ACCESS_COHERENT | ACCESS_VOLATILE)) {
-      LLVMSetOrdering(val, LLVMAtomicOrderingMonotonic);
-      LLVMSetAlignment(val, ac_get_type_size(type));
-   }
-}
-
-static LLVMValueRef visit_global_atomic(struct ac_nir_context *ctx,
-					nir_intrinsic_instr *instr)
-{
-   LLVMValueRef data = get_src(ctx, instr->src[1]);
-   LLVMAtomicRMWBinOp op;
-   LLVMValueRef result;
-
-   /* use "singlethread" sync scope to implement relaxed ordering */
-   const char *sync_scope = "singlethread-one-as";
-
-   nir_atomic_op nir_op = nir_intrinsic_atomic_op(instr);
-   bool is_float = nir_atomic_op_type(nir_op) == nir_type_float;
-
-   LLVMTypeRef data_type = LLVMTypeOf(data);
-
-   assert(instr->src[1].ssa->num_components == 1);
-   if (is_float) {
-      switch (instr->src[1].ssa->bit_size) {
-      case 32:
-         data_type = ctx->ac.f32;
-         break;
-      case 64:
-         data_type = ctx->ac.f64;
-         break;
-      default:
-         unreachable("Unsupported float bit size");
-      }
-
-      data = LLVMBuildBitCast(ctx->ac.builder, data, data_type, "");
-   }
-
-   LLVMValueRef addr = get_global_address(ctx, instr, data_type);
-
-   if (instr->intrinsic == nir_intrinsic_global_atomic_swap ||
-       instr->intrinsic == nir_intrinsic_global_atomic_swap_amd) {
-      LLVMValueRef data1 = get_src(ctx, instr->src[2]);
-      result = ac_build_atomic_cmp_xchg(&ctx->ac, addr, data, data1, sync_scope);
-      result = LLVMBuildExtractValue(ctx->ac.builder, result, 0, "");
-   } else if (nir_op == nir_atomic_op_ordered_add_gfx12_amd) {
-      result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.global.atomic.ordered.add.b64", ctx->ac.i64,
-                                  (LLVMValueRef[]){addr, data}, 2, 0);
-   } else if (is_float) {
-      const char *op = translate_atomic_op_str(nir_op);
-      char name[64], type[8];
-      LLVMValueRef params[2];
-      int arg_count = 0;
-
-      params[arg_count++] = addr;
-      params[arg_count++] = data;
-
-      ac_build_type_name_for_intr(data_type, type, sizeof(type));
-      snprintf(name, sizeof(name), "llvm.amdgcn.global.atomic.%s.%s.p1.%s", op, type, type);
-
-      result = ac_build_intrinsic(&ctx->ac, name, data_type, params, arg_count, 0);
-   } else {
-      op = translate_atomic_op(nir_op);
-      result = ac_build_atomic_rmw(&ctx->ac, op, addr, ac_to_integer(&ctx->ac, data), sync_scope);
-   }
-
-   result = ac_to_integer(&ctx->ac, result);
-
-   return result;
-}
-
 static LLVMValueRef visit_load_ubo_buffer(struct ac_nir_context *ctx, nir_intrinsic_instr *instr)
 {
    struct waterfall_context wctx;
@@ -3141,21 +3018,6 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ssbo:
       result = visit_load_buffer(ctx, instr);
       break;
-   case nir_intrinsic_load_global_constant:
-   case nir_intrinsic_load_global:
-   case nir_intrinsic_load_global_amd:
-      result = visit_load_global(ctx, instr);
-      break;
-   case nir_intrinsic_store_global:
-   case nir_intrinsic_store_global_amd:
-      visit_store_global(ctx, instr);
-      break;
-   case nir_intrinsic_global_atomic:
-   case nir_intrinsic_global_atomic_swap:
-   case nir_intrinsic_global_atomic_amd:
-   case nir_intrinsic_global_atomic_swap_amd:
-      result = visit_global_atomic(ctx, instr);
-      break;
    case nir_intrinsic_ssbo_atomic:
    case nir_intrinsic_ssbo_atomic_swap:
       result = visit_atomic_ssbo(ctx, instr);
-- 
2.45.1

