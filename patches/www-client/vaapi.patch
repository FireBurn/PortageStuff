diff --git a/content/renderer/media/gpu/gpu_video_accelerator_factories_impl.cc b/content/renderer/media/gpu/gpu_video_accelerator_factories_impl.cc
index 90ae6c379d9dd..cf75613874f56 100644
--- a/content/renderer/media/gpu/gpu_video_accelerator_factories_impl.cc
+++ b/content/renderer/media/gpu/gpu_video_accelerator_factories_impl.cc
@@ -334,18 +334,7 @@ GpuVideoAcceleratorFactoriesImpl::IsDecoderConfigSupported(
 
   base::AutoLock lock(supported_profiles_lock_);
 
-  // If GetSupportedConfigs() has not completed (or was never started), report
-  // that all configs are supported. Clients will find out that configs are not
-  // supported when VideoDecoder::Initialize() fails.
-  if (!supported_decoder_configs_)
-    return Supported::kUnknown;
-
-  // Iterate over the supported configs.
-  for (const auto& supported : *supported_decoder_configs_) {
-    if (supported.Matches(config))
-      return Supported::kTrue;
-  }
-  return Supported::kFalse;
+  return Supported::kTrue;
 }
 
 media::VideoDecoderType GpuVideoAcceleratorFactoriesImpl::GetDecoderType() {
diff --git a/media/filters/decoder_selector.cc b/media/filters/decoder_selector.cc
index 3fd950eed5350..601ab9e492676 100644
--- a/media/filters/decoder_selector.cc
+++ b/media/filters/decoder_selector.cc
@@ -331,8 +331,7 @@ void DecoderSelector<StreamType>::OnDecoderInitializeDone(
     // TODO(tmathmeyer) this was too noisy in media log. Batch all the logs
     // together and then send them as an informational notice instead of
     // using NotifyError.
-    MEDIA_LOG(INFO, media_log_)
-        << "Failed to initialize " << decoder_->GetDecoderType();
+    media_log_->NotifyError(std::move(status));
 
     // Try the next decoder on the list.
     decoder_.reset();
diff --git a/media/mojo/services/gpu_mojo_media_client_cros.cc b/media/mojo/services/gpu_mojo_media_client_cros.cc
index 93b454649df0b..f0c5db9fae204 100644
--- a/media/mojo/services/gpu_mojo_media_client_cros.cc
+++ b/media/mojo/services/gpu_mojo_media_client_cros.cc
@@ -44,10 +44,6 @@ VideoDecoderType GetPreferredLinuxDecoderImplementation(
   if (!base::FeatureList::IsEnabled(kVaapiVideoDecodeLinux))
     return VideoDecoderType::kUnknown;
 
-  // Regardless of vulkan support, if direct video decoder is disabled, revert
-  // to using the VDA implementation.
-  if (!base::FeatureList::IsEnabled(kUseChromeOSDirectVideoDecoder))
-    return VideoDecoderType::kVda;
   return VideoDecoderType::kVaapi;
 }
 
@@ -73,6 +69,7 @@ VideoDecoderType GetActualPlatformDecoderImplementation(
         return VideoDecoderType::kUnknown;
       if (gpu_info.vulkan_info->physical_devices.empty())
         return VideoDecoderType::kUnknown;
+      constexpr int kAMD = 0x1022;
       constexpr int kIntel = 0x8086;
       const auto& device = gpu_info.vulkan_info->physical_devices[0];
       switch (device.properties.vendorID) {
@@ -81,9 +78,11 @@ VideoDecoderType GetActualPlatformDecoderImplementation(
             return VideoDecoderType::kUnknown;
           return VideoDecoderType::kVaapi;
         }
+        case kAMD:
+          return VideoDecoderType::kVaapi;
         default: {
           // NVIDIA drivers have a broken implementation of most va_* methods,
-          // ARM & AMD aren't tested yet, and ImgTec/Qualcomm don't have a vaapi
+          // ARM isn't tested yet, and ImgTec/Qualcomm don't have a vaapi
           // driver.
           return VideoDecoderType::kUnknown;
         }
